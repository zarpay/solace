This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*.rb, **/*.md
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
lib/
  solace/
    composers/
      associated_token_account_program_create_account_composer.rb
      base.rb
      spl_token_program_transfer_checked_composer.rb
      system_program_transfer_composer.rb
    concerns/
      binary_serializable.rb
    errors/
      confirmation_timeout.rb
      http_error.rb
      parse_error.rb
      rpc_error.rb
    instructions/
      associated_token_account/
        create_associated_token_account_instruction.rb
      spl_token/
        initialize_account_instruction.rb
        initialize_mint_instruction.rb
        mint_to_instruction.rb
        transfer_checked_instruction.rb
        transfer_instruction.rb
      system_program/
        create_account_instruction.rb
        transfer_instruction.rb
    programs/
      associated_token_account.rb
      base.rb
      spl_token.rb
    serializers/
      address_lookup_table_deserializer.rb
      address_lookup_table_serializer.rb
      base_deserializer.rb
      base_serializer.rb
      instruction_deserializer.rb
      instruction_serializer.rb
      message_deserializer.rb
      message_serializer.rb
      transaction_deserializer.rb
      transaction_serializer.rb
    utils/
      account_context.rb
      codecs.rb
      curve25519_dalek.rb
      pda.rb
      rpc_client.rb
    address_lookup_table.rb
    connection.rb
    constants.rb
    errors.rb
    instruction.rb
    keypair.rb
    message.rb
    public_key.rb
    transaction_composer.rb
    transaction.rb
    version.rb
  solace.rb
test/
  factories/
    instruction_factory.rb
    keypair_factory.rb
    message_factory.rb
    transaction_factory.rb
  solace/
    composers/
      associated_token_account_program_create_account_composer_test.rb
      spl_token_program_transfer_checked_test.rb
      system_program_transfer_composer_test.rb
    instructions/
      associated_token_account/
        create_associated_token_account_instruction_test.rb
      spl_token/
        initialize_account_instruction_test.rb
        initialize_mint_instruction_test.rb
        mint_to_instruction_test.rb
        transfer_checked_instruction_test.rb
        transfer_instruction_test.rb
      system_program/
        create_account_instruction_test.rb
        transfer_instruction_test.rb
    programs/
      associated_token_account_test.rb
      base_test.rb
      spl_token_test.rb
    serializers/
      instruction_deserializer_test.rb
      instruction_serializer_test.rb
      message_deserializer_test.rb
      message_serializer_test.rb
      transaction_deserializer_test.rb
      transaction_serializer_test.rb
    utils/
      account_context_test.rb
      codecs_test.rb
      pda_test.rb
      rpc_client_test.rb
    constants_test.rb
    instruction_test.rb
    keypair_test.rb
    message_test.rb
    public_key_test.rb
    transaction_composer_test.rb
    transaction_test.rb
  support/
    factory_bot.rb
    fixtures.rb
    solana_test_validator.rb
  usecases/
    create_mint.rb
    decode_legacy_transaction.rb
    decode_versioned_transaction.rb
    get_transaction.rb
    legacy_transfer.rb
    sponsored_token_transfer_with_fee.rb
    test_initialize_mint_instruction.rb
    test_token_transfer_sdk.rb
    test_transfer_sdk.rb
    versioned_transfer.rb
  bootstrap.rb
  test_helper.rb
console.rb
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="lib/solace/errors/confirmation_timeout.rb">
# frozen_string_literal: true

module Solace
  module Errors
    # Waiting for confirmation exceeded timeout
    class ConfirmationTimeout < StandardError
      attr_reader :signature, :commitment, :timeout

      # @param [String] message The error message
      # @param [String] signature The signature of the transaction
      # @param [String] commitment The commitment level not reached
      # @param [Integer] timeout The time out reached
      def initialize(message, signature:, commitment:, timeout:)
        super(message)
        @signature = signature
        @commitment = commitment
        @timeout = timeout
      end

      # Formats a confirmation timeout error
      #
      # @params [String] signature The signature of the transaction
      # @params [String] commitment The commitment level not reached
      # @params [Integer] timeout The time out reached
      # @return [Solace::Errors::ConfirmationTimeout] The formatted error
      def self.format(signature, commitment, timeout)
        new(
          "Timed out waiting for signature #{signature} at commitment=#{commitment} after #{timeout}s",
          signature: signature,
          commitment: commitment,
          timeout: timeout
        )
      end
    end
  end
end
</file>

<file path="lib/solace/errors/http_error.rb">
# frozen_string_literal: true

module Solace
  module Errors
    # Non-2xx HTTP or low-level network issues
    class HTTPError < StandardError
      attr_reader :code, :body

      # @param [String] message The error message
      # @param [Integer] code The HTTP status code
      # @param [String] body The HTTP response body
      def initialize(message, code:, body: nil)
        super(message)
        @code = code
        @body = body
      end

      # Formats a response to an error
      #
      # @param response [Net::HTTPResponse] The HTTP response
      # @return [Solace::Errors::HTTPError] The formatted error
      def self.format_response(response)
        new("HTTP error: #{response.message}", code: response.code.to_i, body: response.body)
      end

      # Formats transport errors
      #
      # @param error [SocketError, IOError] The transport error
      # @return [Solace::Errors::HTTPError] The formatted error
      def self.format_transport_error(error)
        new("HTTP transport error: #{error.message}", code: 0)
      end

      # Formats timeout errors
      #
      # @param error [Net::OpenTimeout, Net::ReadTimeout] The timeout error
      # @return [Solace::Errors::HTTPError] The formatted error
      def self.format_timeout_error(error)
        new("HTTP timeout: #{error.class}", code: 408)
      end
    end
  end
end
</file>

<file path="lib/solace/errors/parse_error.rb">
# frozen_string_literal: true

module Solace
  module Errors
    # JSON parsing failed
    class ParseError < StandardError
      attr_reader :body

      # @param [String] message The error message
      # @param [Object] body The response body
      def initialize(message, body:)
        super(message)
        @body = body
      end

      # Formats a response to an error
      #
      # @param error [JSON::ParserError] The JSON-RPC error
      # @param [Object] response The response from the RPC
      # @return [Solace::Errors::ParseError] The formatted error
      def self.format_response(error, response)
        new("Invalid JSON from RPC: #{error.message}", body: response.body)
      end
    end
  end
end
</file>

<file path="lib/solace/errors/rpc_error.rb">
# frozen_string_literal: true

module Solace
  module Errors
    # JSON-RPC returned an "error" object
    class RPCError < StandardError
      attr_reader :rpc_code, :rpc_message, :rpc_data

      # @param [String] message The error message
      # @param [Integer] rpc_code The JSON-RPC error code
      # @param [String] rpc_message The JSON-RPC error message
      # @param [Object] rpc_data The JSON-RPC error data
      def initialize(message, rpc_code:, rpc_message:, rpc_data: nil)
        super(message)
        @rpc_code = rpc_code
        @rpc_message = rpc_message
        @rpc_data = rpc_data
      end

      # Formats a response to an error
      #
      # @param response [Hash] The JSON-RPC response
      # @return [Solace::Errors::RPCError] The formatted error
      def self.format_response(response)
        new(
          "RPC error #{response['error']['code']}: #{response['error']['message']}",
          rpc_data: response['error']['data'],
          rpc_code: response['error']['code'],
          rpc_message: response['error']['message']
        )
      end

      # @return [Hash] The error as a hash
      def to_h = { code: rpc_code, message: rpc_message, data: rpc_data }
    end
  end
end
</file>

<file path="lib/solace/errors.rb">
# frozen_string_literal: true

module Solace
  # Error handling module
  #
  # This module provides error classes for handling different types of errors that may occur during
  # Solana RPC requests and processing transactions.
  #
  # @since 0.0.8
  module Errors
    # JSON-RPC Errors
    require 'solace/errors/rpc_error'
    require 'solace/errors/http_error'
    require 'solace/errors/parse_error'
    require 'solace/errors/confirmation_timeout'
  end
end
</file>

<file path="test/solace/instructions/spl_token/transfer_checked_instruction_test.rb">
# frozen_string_literal: true

require 'test_helper'

describe Solace::Instructions::SplToken::TransferCheckedInstruction do
  describe '.build' do
    let(:amount) { 100 }
    let(:decimals) { 6 }

    # Build a transfer instruction
    let(:ix) do
      Solace::Instructions::SplToken::TransferCheckedInstruction.build(
        amount: amount,
        decimals: decimals,
        to_index: 0,
        from_index: 1,
        mint_index: 2,
        authority_index: 4
      )
    end

    it 'returns an instruction' do
      assert_kind_of Solace::Instruction, ix
    end

    it 'sets the default program index' do
      assert_equal 3, ix.program_index
    end

    it 'has the correct accounts' do
      assert_equal [1, 2, 0, 4], ix.accounts
    end

    it 'has the correct data' do
      assert_equal [12] + [amount].pack('Q<').bytes + [decimals], ix.data
    end

    describe 'with custom program index' do
      let(:program_index) { 5 }

      let(:ix_with_custom_program_index) do
        Solace::Instructions::SplToken::TransferCheckedInstruction.build(
          amount: amount,
          decimals: decimals,
          to_index: 0,
          from_index: 1,
          mint_index: 2,
          authority_index: 4,
          program_index: program_index
        )
      end

      it 'sets the custom program index' do
        assert_equal program_index, ix_with_custom_program_index.program_index
      end
    end
  end
end
</file>

<file path="test/solace/utils/rpc_client_test.rb">
# frozen_string_literal: true

require 'test_helper'

describe Solace::Utils::RPCClient do
  let(:url) { 'http://localhost:8899' }
  let(:open_timeout) { 10 }
  let(:read_timeout) { 10 }

  let(:client) { Solace::Utils::RPCClient.new(url, open_timeout: open_timeout, read_timeout: read_timeout) }

  describe '#initialize' do
    it 'assigns url' do
      assert_equal url, client.url
    end

    it 'assigns open_timeout' do
      assert_equal open_timeout, client.open_timeout
    end

    it 'assigns read_timeout' do
      assert_equal read_timeout, client.read_timeout
    end
  end

  describe '#rpc_request' do
    let(:method_name) { 'getMinimumBalanceForRentExemption' }
    let(:params) { [100] }

    it 'calls the RPC endpoint with the correct method and params' do
      response = client.rpc_request(method_name, params)

      assert_kind_of String, response['id']
      assert_kind_of Integer, response['result']
      assert_equal '2.0', response['jsonrpc']
    end

    it 'raises HTTPError timeout when the request times out' do
      Net::HTTP.stub(:start, ->(*) { raise Net::OpenTimeout }) do
        error = assert_raises(Solace::Errors::HTTPError) do
          client.rpc_request(method_name, params)
        end

        assert_equal 408, error.code
      end
    end

    it 'raises HTTPError timeout when there is a read timeout' do
      Net::HTTP.stub(:start, ->(*) { raise Net::ReadTimeout }) do
        error = assert_raises(Solace::Errors::HTTPError) do
          client.rpc_request(method_name, params)
        end

        assert_equal 408, error.code
      end
    end

    it 'raises HTTPError transport when there is a socket error' do
      Net::HTTP.stub(:start, ->(*) { raise SocketError }) do
        error = assert_raises(Solace::Errors::HTTPError) do
          client.rpc_request(method_name, params)
        end

        assert_equal 0, error.code
      end
    end

    it 'raises HTTPError transport when there is an IO error' do
      Net::HTTP.stub(:start, ->(*) { raise IOError }) do
        error = assert_raises(Solace::Errors::HTTPError) do
          client.rpc_request(method_name, params)
        end

        assert_equal 0, error.code
      end
    end

    it 'raises HTTPError when the response is not a success' do
      # Create a Net::HTTPBadRequest instance
      bad_request_response = Net::HTTPBadRequest.new('1.1', 400, 'Bad Request')
      bad_request_response.instance_variable_set(:@read, true) # mark as already read
      bad_request_response.body = 'Mocked body here'

      Net::HTTP.stub(:start, ->(*) { bad_request_response }) do
        error = assert_raises(Solace::Errors::HTTPError) do
          client.rpc_request(method_name, params)
        end

        assert_equal 'HTTP error: Bad Request', error.message
        assert_equal 'Mocked body here', error.body
        assert_equal 400, error.code
      end
    end

    it 'raises ParseError when the response is not a valid JSON' do
      # Create a Net::HTTPSuccess instance
      text_response = Net::HTTPSuccess.new('1.1', 200, 'OK')
      text_response.instance_variable_set(:@read, true)
      text_response.body = 'this is not a valid JSON'

      Net::HTTP.stub(:start, ->(*) { text_response }) do
        error = assert_raises(Solace::Errors::ParseError) do
          client.rpc_request(method_name, params)
        end

        assert_equal 'this is not a valid JSON', error.body
        assert_match(/Invalid JSON from RPC:/, error.message)
      end
    end

    it 'raises RPCError when the response is a JSON-RPC error' do
      # Create a Net::HTTPSuccess instance
      json_rpc_error_response = Net::HTTPSuccess.new('1.1', 200, 'OK')
      json_rpc_error_response.instance_variable_set(:@read, true)
      json_rpc_error_response.body = JSON.dump({ jsonrpc: '2.0', id: '1', error: { code: -32_601, message: 'Method not found', data: 'data' } })

      Net::HTTP.stub(:start, ->(*) { json_rpc_error_response }) do
        error = assert_raises(Solace::Errors::RPCError) do
          client.rpc_request(method_name, params)
        end

        assert_equal 'RPC error -32601: Method not found', error.message
        assert_equal(-32_601, error.rpc_code)
        assert_equal 'data', error.rpc_data
      end
    end
  end
end
</file>

<file path="test/solace/constants_test.rb">
# frozen_string_literal: true

require 'bundler'
require 'test_helper'

describe Solace::Constants do
  let(:constants_path) { Bundler.root.join('tmp/constants.yml').to_s }

  describe '.load' do
    before(:all) do
      File.write(constants_path, <<~YAML)
        # Devnet
        devnet:
          my_program_id: my_program_id_devnet
          squads_program_id: squads_program_id_devnet
          usdc_mint_account: usdc_mint_account_devnet
          usdt_mint_account: usdt_mint_account_devnet
        # Mainnet
        mainnet:
          my_program_id: my_program_id_mainnet
          squads_program_id: squads_program_id_mainnet
          usdc_mint_account: usdc_mint_account_mainnet
          usdt_mint_account: usdt_mint_account_mainnet
      YAML
    end

    it 'loads all constants from a namespaced YAML file and uppercase them' do
      Solace::Constants.load(path: constants_path, namespace: 'devnet', protect_overrides: false)

      assert_equal Solace::Constants::MY_PROGRAM_ID, 'my_program_id_devnet'
      assert_equal Solace::Constants::SQUADS_PROGRAM_ID, 'squads_program_id_devnet'
      assert_equal Solace::Constants::USDC_MINT_ACCOUNT, 'usdc_mint_account_devnet'
      assert_equal Solace::Constants::USDT_MINT_ACCOUNT, 'usdt_mint_account_devnet'
    end

    it 'raises an error if a constant is already defined' do
      Solace::Constants.load(path: constants_path, namespace: 'devnet', protect_overrides: false)

      assert_raises(ArgumentError, 'Constant MY_PROGRAM_ID is already defined') do
        Solace::Constants.load(path: constants_path, namespace: 'mainnet')
      end
    end

    it 'allows overriding constants if protect_overrides is false' do
      # Reload the constants with protect_overrides set to false
      Solace::Constants.load(path: constants_path, namespace: 'mainnet', protect_overrides: false)

      # Verify that the constants have been overridden
      assert_equal Solace::Constants::MY_PROGRAM_ID, 'my_program_id_mainnet'
      assert_equal Solace::Constants::SQUADS_PROGRAM_ID, 'squads_program_id_mainnet'
      assert_equal Solace::Constants::USDC_MINT_ACCOUNT, 'usdc_mint_account_mainnet'
      assert_equal Solace::Constants::USDT_MINT_ACCOUNT, 'usdt_mint_account_mainnet'
    end
  end
end
</file>

<file path="lib/solace/instructions/spl_token/transfer_checked_instruction.rb">
# frozen_string_literal: true

module Solace
  module Instructions
    module SplToken
      # Instruction for transferring SPL tokens.
      #
      # This instruction is used to transfer SPL tokens from one token account to another while checking the decimals
      # of the token to ensure the transfer amount is correct.
      #
      # @example Build a TransferChecked instruction
      #   instruction = Solace::Instructions::SplToken::TransferCheckedInstruction.build(
      #     amount: 100,
      #     decimals: 6,
      #     to_index: 1,
      #     from_index: 2,
      #     mint_index: 3,
      #     authority_index: 4,
      #     program_index: 5
      #   )
      #
      # @since 0.0.2
      class TransferCheckedInstruction
        # SPL Token Program instruction index for Transfer Checked
        INSTRUCTION_INDEX = [12].freeze

        # Builds a Solace::Instruction for transferring SPL tokens
        #
        # SPL Token Program transfer instruction layout:
        #   - 1 byte: instruction index (12 for transfer checked)
        #   - 8 bytes: amount (u64, little-endian)
        #   - 8 bytes: decimals (u64, little-endian)
        #
        # @param amount [Integer] Amount to transfer (in tokens, according to mint's decimals)
        # @param decimals [Integer] Number of decimals for the token
        # @param to_index [Integer] Index of the destination token account in the transaction's accounts
        # @param from_index [Integer] Index of the source token account in the transaction's accounts
        # @param mint_index [Integer] Index of the mint in the transaction's accounts
        # @param authority_index [Integer] Index of the authority (owner) in the transaction's accounts
        # @param program_index [Integer] Index of the SPL Token Program in the transaction's accounts (default: 3)
        # @return [Solace::Instruction]
        def self.build(
          amount:,
          decimals:,
          to_index:,
          from_index:,
          mint_index:,
          authority_index:,
          program_index: 3
        )
          Solace::Instruction.new.tap do |ix|
            ix.program_index = program_index
            ix.accounts = [from_index, mint_index, to_index, authority_index]
            ix.data = data(amount, decimals)
          end
        end

        # Instruction data for a token transfer instruction
        #
        # The BufferLayout is:
        #   - [Instruction Index (1 byte)]
        #   - [Amount (8 bytes little-endian u64)]
        #   - [Decimals (8 bytes little-endian u64)]
        #
        # @param amount [Integer] Amount to transfer
        # @param decimals [Integer] Number of decimals for the token
        # @return [Array] 1-byte instruction index + 8-byte amount + decimals
        def self.data(amount, decimals)
          INSTRUCTION_INDEX +
            Solace::Utils::Codecs.encode_le_u64(amount).bytes +
            [decimals]
        end
      end
    end
  end
end
</file>

<file path="lib/solace/instructions/spl_token/transfer_instruction.rb">
# frozen_string_literal: true

module Solace
  module Instructions
    module SplToken
      # Instruction for transferring SPL tokens.
      #
      # This instruction is used to transfer SPL tokens from one token account to another.
      #
      # @example Build a Transfer instruction
      #   instruction = Solace::Instructions::SplToken::TransferInstruction.build(
      #     amount: 100,
      #     owner_index: 1,
      #     source_index: 2,
      #     destination_index: 3,
      #     program_index: 4
      #   )
      #
      # @since 0.0.2
      class TransferInstruction
        # @!attribute [Array<Integer>] INSTRUCTION_INDEX
        #   Instruction index for SPL Token Program's Transfer instruction.
        INSTRUCTION_INDEX = [3].freeze

        # Builds a Transfer instruction.
        #
        # @param amount [Integer] The amount of tokens to transfer.
        # @param source_index [Integer] The index of the source token account.
        # @param destination_index [Integer] The index of the destination token account.
        # @param owner_index [Integer] The index of the source account's owner.
        # @param program_index [Integer] The index of the SPL Token Program.
        # @return [Solace::Instruction]
        def self.build(
          amount:,
          owner_index:,
          source_index:,
          destination_index:,
          program_index:
        )
          Solace::Instruction.new.tap do |ix|
            ix.program_index = program_index
            ix.accounts = [source_index, destination_index, owner_index]
            ix.data = data(amount)
          end
        end

        # Builds the data for a Transfer instruction.
        #
        # The BufferLayout is:
        #   - [Instruction Index (1 byte)]
        #   - [Amount (8 bytes)]
        #
        # @param amount [Integer] The amount of tokens to transfer.
        # @return [Array<Integer>] 1-byte instruction index + 8-byte amount
        def self.data(amount)
          INSTRUCTION_INDEX + Solace::Utils::Codecs.encode_le_u64(amount).bytes
        end
      end
    end
  end
end
</file>

<file path="lib/solace/utils/rpc_client.rb">
# frozen_string_literal: true

require 'net/http'
require 'json'
require 'uri'

require 'solace/errors'

module Solace
  module Utils
    # RPCClient provides Net::HTTP based HTTP client for sending HTTP
    # requests to a Solana RPC node and parsing responses.
    #
    # @since 0.0.8
    class RPCClient
      # @!attribute [r] url
      #   The URL for the HTTP request
      attr_reader :url

      # @!attribute [r] open_timeout
      #   The timeout for opening an HTTP connection
      attr_reader :open_timeout

      # @!attribute [r] read_timeout
      #   The timeout for reading an HTTP response
      attr_reader :read_timeout

      # Initialize the connection with a default or custom RPC URL
      #
      # @param url [String] The URL of the Solana RPC node
      # @param open_timeout [Integer] The timeout for opening an HTTP connection
      # @param read_timeout [Integer] The timeout for reading an HTTP response
      def initialize(
        url,
        open_timeout:,
        read_timeout:
      )
        @url = url
        @open_timeout = open_timeout
        @read_timeout = read_timeout
      end

      # Sends a JSON-RPC request to the configured Solana RPC server.
      #
      # @param method [String] the JSON-RPC method name
      # @param params [Array] the parameters for the RPC method
      # @return [Hash] the parsed JSON response
      # @raise [
      #   Solace::Errors::HTTPError,
      #   Solace::Errors::ParseError,
      #   Solace::Errors::RPCError,
      #   Solace::Errors::ConfirmationTimeout
      # ]
      def rpc_request(method, params = [])
        request = build_rpc_request(method, params)
        response = perform_http_request(*request)
        handle_rpc_response(response)
      end

      private

      # Builds a JSON-RPC request
      #
      # @param method [String] the JSON-RPC method name
      # @param params [Array] the parameters for the RPC method
      # @return [Array] the URI and request object
      def build_rpc_request(method, params)
        uri = URI(url)

        req = Net::HTTP::Post.new(uri)
        req['Accept'] = 'application/json'
        req['Content-Type'] = 'application/json'
        req.body = build_request_body(method, params)

        [uri, req]
      end

      # Builds request body
      #
      # @param method [String] the JSON-RPC method name
      # @param params [Array] the parameters for the RPC method
      # @return [String] the request body
      def build_request_body(method, params)
        {
          jsonrpc: '2.0',
          id: SecureRandom.uuid,
          method: method,
          params: params
        }.to_json
      end

      # Performs an HTTP request to the configured Solana RPC server.
      #
      # @param uri [URI] the URI for the HTTP request
      # @param req [Net::HTTP::Post] the request object
      # @return [Net::HTTPResponse] the HTTP response
      # @raise [Solace::Errors::HTTPError]
      def perform_http_request(uri, req)
        Net::HTTP.start(
          uri.hostname,
          uri.port,
          use_ssl: uri.scheme == 'https',
          open_timeout: open_timeout,
          read_timeout: read_timeout
        ) do |http|
          http.request(req)
        end
      rescue Net::OpenTimeout, Net::ReadTimeout => e
        raise Errors::HTTPError.format_timeout_error(e)
      rescue SocketError, IOError => e
        raise Errors::HTTPError.format_transport_error(e)
      end

      # Handles the response from the HTTP request
      #
      # @param response [Net::HTTPResponse] The HTTP response
      # @return [Hash] The parsed JSON response
      # @raise [Solace::Errors::HTTPError]
      # @raise [Solace::Errors::ParseError]
      # @raise [Solace::Errors::RPCError]
      def handle_rpc_response(response)
        raise Errors::HTTPError.format_response(response) unless response.is_a?(Net::HTTPSuccess)

        json = JSON.parse(response.body)

        raise Errors::RPCError.format_response(json) if json['error']

        json
      rescue JSON::ParserError => e
        raise Errors::ParseError.format_response(e, response)
      end
    end
  end
end
</file>

<file path="test/factories/keypair_factory.rb">
# frozen_string_literal: true

FactoryBot.define do
  factory :funded_keypair, class: Solace::Keypair do
    transient do
      amount { 10_000_000_000 }
    end

    initialize_with do
      keypair = Solace::Keypair.generate

      conn = Solace::Connection.new

      # Request airdrop and wait for confirmation
      conn.wait_for_confirmed_signature do
        conn.request_airdrop(keypair.address, amount)['result']
      end

      # Return the keypair
      keypair
    end
  end
end
</file>

<file path="test/solace/composers/associated_token_account_program_create_account_composer_test.rb">
# frozen_string_literal: true

require 'test_helper'

describe Solace::Composers::AssociatedTokenAccountProgramCreateAccountComposer do
  let(:mint) { Fixtures.load_keypair('mint') }
  let(:funder) { Fixtures.load_keypair('bob') }
  let(:payer) { Fixtures.load_keypair('payer') }

  let(:connection) { Solace::Connection.new }
  let(:transaction_composer) { Solace::TransactionComposer.new(connection: connection) }

  describe 'sponsored transaction' do
    let(:owner) { Solace::Keypair.generate }
    let(:owner_ata) { Solace::Programs::AssociatedTokenAccount.get_address(owner: owner, mint: mint).first }

    let(:composer) do
      Solace::Composers::AssociatedTokenAccountProgramCreateAccountComposer.new(
        mint: mint,
        owner: owner,
        funder: funder,
        ata_address: owner_ata
      )
    end

    before(:all) do
      # Get starting balances and data
      @account_starting_data = connection.get_account_info(owner_ata)
      @payer_starting_balance = connection.get_balance(payer.address)
      @funder_starting_balance = connection.get_balance(funder.address)

      # Set fee payer and add instruction
      transaction_composer.add_instruction(composer)
      transaction_composer.set_fee_payer(payer)

      # Compose and sign transaction
      tx = transaction_composer.compose_transaction
      tx.sign(payer, funder)

      # Send transaction and wait for confirmation
      @signature = connection.send_transaction(tx.serialize)
      connection.wait_for_confirmed_signature { @signature['result'] }

      # Get ending balances
      @account_ending_data = connection.get_account_info(owner_ata)
      @payer_ending_balance = connection.get_balance(payer.address)
      @funder_ending_balance = connection.get_balance(funder.address)
    end

    it 'creates the account' do
      assert_nil @account_starting_data
      assert_operator @account_ending_data, :!=, nil
    end

    it 'funds account using funder balance' do
      assert_operator @funder_starting_balance, :>, @funder_ending_balance
    end

    it 'deducts fees from payer' do
      assert_equal @payer_ending_balance, @payer_starting_balance - (2 * 5000)
    end
  end

  describe 'owner-funded transaction' do
    let(:owner) { Solace::Keypair.generate }
    let(:owner_starting_balance) { 5_000_000 }
    let(:owner_ata) { Solace::Programs::AssociatedTokenAccount.get_address(owner: owner, mint: mint).first }

    let(:sol_transfer_composer) do
      Solace::Composers::SystemProgramTransferComposer.new(
        to: owner,
        from: payer,
        lamports: owner_starting_balance
      )
    end

    let(:create_account_composer) do
      Solace::Composers::AssociatedTokenAccountProgramCreateAccountComposer.new(
        mint: mint,
        owner: owner,
        funder: owner,
        ata_address: owner_ata
      )
    end

    before(:all) do
      # Get starting balances and data
      @account_starting_data = connection.get_account_info(owner_ata)

      # Set fee payer and add instructions
      #   The payer will first transfer SOL to the owener so that the owner
      #   may fund their own token account's rent exemption.
      transaction_composer.add_instruction(sol_transfer_composer)
      transaction_composer.add_instruction(create_account_composer)
      transaction_composer.set_fee_payer(payer)

      # Compose and sign transaction
      tx = transaction_composer.compose_transaction
      tx.sign(payer, owner)

      # Send transaction and wait for confirmation
      response = connection.send_transaction(tx.serialize)
      connection.wait_for_confirmed_signature { response['result'] }

      # Get ending balances
      @account_ending_balance = connection.get_balance(owner_ata)
      @owner_ending_balance = connection.get_balance(owner.address)
    end

    it 'creates the account with funding' do
      assert_nil @account_starting_data
      assert_operator @account_ending_balance, :>, 0
    end

    it 'deducts funding from owner' do
      assert_equal @owner_ending_balance, owner_starting_balance - @account_ending_balance
    end
  end
end
</file>

<file path="test/solace/composers/spl_token_program_transfer_checked_test.rb">
# frozen_string_literal: true

require 'test_helper'

describe Solace::Composers::SplTokenProgramTransferCheckedComposer do
  let(:bob) { Fixtures.load_keypair('bob') }
  let(:anna) { Fixtures.load_keypair('anna') }
  let(:payer) { Fixtures.load_keypair('payer') }
  let(:mint) { Fixtures.load_keypair('mint') }
  let(:fee_collector) { Fixtures.load_keypair('fee-collector') }

  let(:bob_ata) { Solace::Programs::AssociatedTokenAccount.get_address(owner: bob, mint: mint).first }
  let(:anna_ata) { Solace::Programs::AssociatedTokenAccount.get_address(owner: anna, mint: mint).first }
  let(:fee_collector_ata) { Solace::Programs::AssociatedTokenAccount.get_address(owner: fee_collector, mint: mint).first }

  let(:decimals) { 6 }
  let(:amount) { 1_000 }

  let(:connection) { Solace::Connection.new }
  let(:transaction_composer) { Solace::TransactionComposer.new(connection: connection) }

  describe 'sponsored transaction' do
    let(:composer) do
      Solace::Composers::SplTokenProgramTransferCheckedComposer.new(
        mint: mint,
        to: anna_ata,
        from: bob_ata,
        authority: bob,
        amount: amount,
        decimals: decimals
      )
    end

    before(:all) do
      # Get starting balances
      @payer_starting_balance = connection.get_balance(payer.address)
      @bob_starting_token_balance = connection.get_token_account_balance(bob_ata)['amount'].to_i
      @anna_starting_token_balance = connection.get_token_account_balance(anna_ata)['amount'].to_i

      # Set fee payer and add instruction
      transaction_composer.add_instruction(composer)
      transaction_composer.set_fee_payer(payer)

      # Compose and sign transaction
      tx = transaction_composer.compose_transaction
      tx.sign(payer, bob)

      # Send transaction and wait for confirmation
      @signature = connection.send_transaction(tx.serialize)
      connection.wait_for_confirmed_signature { @signature['result'] }

      # Get ending balances
      @payer_ending_balance = connection.get_balance(payer.address)
      @bob_ending_token_balance = connection.get_token_account_balance(bob_ata)['amount'].to_i
      @anna_ending_token_balance = connection.get_token_account_balance(anna_ata)['amount'].to_i
    end

    it 'transfers tokens from bob' do
      assert_equal @bob_ending_token_balance, @bob_starting_token_balance - amount
    end

    it 'transfers tokens to anna' do
      assert_equal @anna_ending_token_balance, @anna_starting_token_balance + amount
    end

    it 'deducts fees from payer' do
      assert_equal @payer_ending_balance, @payer_starting_balance - (2 * 5000)
    end
  end

  describe 'non-sponsored transaction' do
    let(:composer) do
      Solace::Composers::SplTokenProgramTransferCheckedComposer.new(
        mint: mint,
        to: anna_ata,
        from: bob_ata,
        authority: bob,
        amount: amount,
        decimals: decimals
      )
    end

    before(:all) do
      # Get starting balances
      @bob_starting_balance = connection.get_balance(bob.address)
      @bob_starting_token_balance = connection.get_token_account_balance(bob_ata)['amount'].to_i
      @anna_starting_token_balance = connection.get_token_account_balance(anna_ata)['amount'].to_i

      # Add instruction and set fee payer
      transaction_composer.add_instruction(composer)
      transaction_composer.set_fee_payer(bob)

      # Compose and sign transaction
      tx = transaction_composer.compose_transaction
      tx.sign(bob)

      # Send transaction and wait for confirmation
      @signature = connection.send_transaction(tx.serialize)
      connection.wait_for_confirmed_signature { @signature['result'] }

      # Get ending balances
      @bob_ending_balance = connection.get_balance(bob.address)
      @bob_ending_token_balance = connection.get_token_account_balance(bob_ata)['amount'].to_i
      @anna_ending_token_balance = connection.get_token_account_balance(anna_ata)['amount'].to_i
    end

    it 'transfers tokens from bob' do
      assert_equal @bob_ending_token_balance, @bob_starting_token_balance - amount
    end

    it 'transfers tokens to anna' do
      assert_equal @anna_ending_token_balance, @anna_starting_token_balance + amount
    end

    it 'deducts fees from bob' do
      assert_equal @bob_ending_balance, @bob_starting_balance - 5000
    end
  end

  describe 'transaction with multiple instructions' do
    let(:fee) { 10_000 }
    let(:lamports) { 50_000 }

    let(:composer1) do
      Solace::Composers::SplTokenProgramTransferCheckedComposer.new(
        mint: mint,
        to: anna_ata,
        from: bob_ata,
        authority: bob,
        amount: amount,
        decimals: decimals
      )
    end

    let(:composer2) do
      Solace::Composers::SplTokenProgramTransferCheckedComposer.new(
        mint: mint,
        to: fee_collector_ata,
        from: bob_ata,
        authority: bob,
        amount: fee,
        decimals: decimals
      )
    end

    let(:composer3) do
      Solace::Composers::SystemProgramTransferComposer.new(
        to: bob,
        from: anna,
        lamports: lamports
      )
    end

    before(:all) do
      # Get starting balances
      @payer_starting_balance = connection.get_balance(payer.address)
      @bob_starting_balance = connection.get_balance(bob.address)
      @anna_starting_balance = connection.get_balance(anna.address)

      @bob_starting_token_balance = connection.get_token_account_balance(bob_ata)['amount'].to_i
      @anna_starting_token_balance = connection.get_token_account_balance(anna_ata)['amount'].to_i
      @fee_collector_starting_balance = connection.get_token_account_balance(fee_collector_ata)['amount'].to_i

      # Add instructions and set fee payer
      transaction_composer.add_instruction(composer1)
      transaction_composer.add_instruction(composer2)
      transaction_composer.add_instruction(composer3)
      transaction_composer.set_fee_payer(payer)

      # Compose and sign transaction
      tx = transaction_composer.compose_transaction
      tx.sign(payer, bob, anna)

      # Send transaction and wait for confirmation
      @signature = connection.send_transaction(tx.serialize)
      connection.wait_for_confirmed_signature { @signature['result'] }

      # Get ending balances
      @payer_ending_balance = connection.get_balance(payer.address)
      @bob_ending_balance = connection.get_balance(bob.address)
      @anna_ending_balance = connection.get_balance(anna.address)

      @bob_ending_token_balance = connection.get_token_account_balance(bob_ata)['amount'].to_i
      @anna_ending_token_balance = connection.get_token_account_balance(anna_ata)['amount'].to_i
      @fee_collector_ending_balance = connection.get_token_account_balance(fee_collector_ata)['amount'].to_i
    end

    it 'transfers tokens from bob' do
      assert_equal @bob_ending_token_balance, @bob_starting_token_balance - (amount + fee)
    end

    it 'transfers tokens to anna' do
      assert_equal @anna_ending_token_balance, @anna_starting_token_balance + amount
    end

    it 'transfers tokens to fee collector' do
      assert_equal @fee_collector_ending_balance, @fee_collector_starting_balance + fee
    end

    it 'transfers lamports to bob' do
      assert_equal @bob_ending_balance, @bob_starting_balance + lamports
    end

    it 'transfers lamports from anna' do
      assert_equal @anna_ending_balance, @anna_starting_balance - lamports
    end

    it 'deducts fees from payer' do
      assert_equal @payer_ending_balance, @payer_starting_balance - (
        5000 + # transfer from anna
        5000 + # transfer from bob
        5000 # fee payer signature
      )
    end
  end
end
</file>

<file path="test/solace/composers/system_program_transfer_composer_test.rb">
# frozen_string_literal: true

require 'test_helper'

describe Solace::Composers::SystemProgramTransferComposer do
  let(:bob) { Fixtures.load_keypair('bob') }
  let(:anna) { Fixtures.load_keypair('anna') }
  let(:payer) { Fixtures.load_keypair('payer') }

  let(:connection) { Solace::Connection.new }
  let(:transaction_composer) { Solace::TransactionComposer.new(connection: connection) }

  describe 'sponsored transaction' do
    let(:composer) do
      Solace::Composers::SystemProgramTransferComposer.new(
        to: anna,
        from: bob,
        lamports: 10_000
      )
    end

    before(:all) do
      # Get starting balances
      @bob_starting_balance = connection.get_balance(bob.address)
      @anna_starting_balance = connection.get_balance(anna.address)
      @payer_starting_balance = connection.get_balance(payer.address)

      # Add instruction and set fee payer
      transaction_composer.add_instruction(composer)
      transaction_composer.set_fee_payer(payer)

      # Compose and sign transaction
      tx = transaction_composer.compose_transaction
      tx.sign(payer, bob)

      # Send transaction and wait for confirmation
      @signature = connection.send_transaction(tx.serialize)
      connection.wait_for_confirmed_signature { @signature['result'] }

      # Get ending balances
      @bob_ending_balance = connection.get_balance(bob.address)
      @anna_ending_balance = connection.get_balance(anna.address)
      @payer_ending_balance = connection.get_balance(payer.address)
    end

    it 'it deducts lamports from the payer' do
      # 2 signatures + 5000 lamports per signature
      assert_equal @payer_ending_balance, @payer_starting_balance - (2 * 5000)
    end

    it 'sends lamports to the correct address' do
      assert_equal @anna_ending_balance, @anna_starting_balance + 10_000
    end

    it 'sends lamports from the correct address' do
      assert_equal @bob_ending_balance, @bob_starting_balance - 10_000
    end
  end

  describe 'non-sponsored transaction' do
    let(:composer) do
      Solace::Composers::SystemProgramTransferComposer.new(
        to: anna,
        from: bob,
        lamports: 10_000
      )
    end

    before(:all) do
      # Get starting balances
      @bob_starting_balance = connection.get_balance(bob.address)
      @anna_starting_balance = connection.get_balance(anna.address)

      # Add instruction and set fee payer
      transaction_composer.add_instruction(composer)
      transaction_composer.set_fee_payer(bob)

      # Compose and sign transaction
      tx = transaction_composer.compose_transaction
      tx.sign(bob)

      # Send transaction and wait for confirmation
      @signature = connection.send_transaction(tx.serialize)
      connection.wait_for_confirmed_signature { @signature['result'] }

      # Get ending balances
      @bob_ending_balance = connection.get_balance(bob.address)
      @anna_ending_balance = connection.get_balance(anna.address)
    end

    it 'sends lamports to the correct address' do
      assert_equal @anna_ending_balance, @anna_starting_balance + 10_000
    end

    it 'sends lamports and fees from the correct address' do
      # 1 signature + 5000 lamports per signature
      assert_equal @bob_ending_balance, @bob_starting_balance - (10_000 + 5000)
    end
  end

  describe 'sponsored transaction with multiple instructions' do
    let(:composer1) do
      Solace::Composers::SystemProgramTransferComposer.new(
        to: bob,
        from: payer,
        lamports: 10_000
      )
    end

    let(:composer2) do
      Solace::Composers::SystemProgramTransferComposer.new(
        to: anna,
        from: payer,
        lamports: 10_000
      )
    end

    before(:all) do
      # Get starting balances
      @bob_starting_balance = connection.get_balance(bob.address)
      @anna_starting_balance = connection.get_balance(anna.address)
      @payer_starting_balance = connection.get_balance(payer.address)

      # Add instructions and set fee payer
      transaction_composer.add_instruction(composer1)
      transaction_composer.add_instruction(composer2)
      transaction_composer.set_fee_payer(payer)

      # Compose and sign transaction
      tx = transaction_composer.compose_transaction
      tx.sign(payer)

      # Send transaction and wait for confirmation
      @signature = connection.send_transaction(tx.serialize)
      connection.wait_for_confirmed_signature { @signature['result'] }

      # Get ending balances
      @bob_ending_balance = connection.get_balance(bob.address)
      @anna_ending_balance = connection.get_balance(anna.address)
      @payer_ending_balance = connection.get_balance(payer.address)
    end

    it 'sends lamports to anna' do
      assert_equal @anna_ending_balance, @anna_starting_balance + 10_000
    end

    it 'sends lamports to bob' do
      assert_equal @bob_ending_balance, @bob_starting_balance + 10_000
    end

    it 'sends lamports and fees from payer' do
      # 1 signature + 5000 lamports per signature
      assert_equal @payer_ending_balance, @payer_starting_balance - (
        10_000 + # transfer to anna
        10_000 + # transfer to bob
        5000 # signature
      )
    end
  end
end
</file>

<file path="test/solace/instructions/spl_token/initialize_account_instruction_test.rb">
# frozen_string_literal: true

require 'test_helper'

describe Solace::Instructions::SplToken::InitializeAccountInstruction do
  describe 'build' do
    let(:account_index) { 0 }
    let(:mint_index) { 1 }
    let(:owner_index) { 2 }
    let(:rent_sysvar_index) { 3 }
    let(:program_index) { 4 }

    let(:ix) do
      Solace::Instructions::SplToken::InitializeAccountInstruction.build(
        account_index: account_index,
        mint_index: mint_index,
        owner_index: owner_index,
        rent_sysvar_index: rent_sysvar_index,
        program_index: program_index
      )
    end

    it 'should build a valid instruction' do
      assert_kind_of Solace::Instruction, ix
    end

    it 'should have the correct program index' do
      assert_equal program_index, ix.program_index
    end

    it 'should have the correct accounts' do
      assert_equal [account_index, mint_index, owner_index, rent_sysvar_index], ix.accounts
    end

    it 'should have the correct data' do
      assert_equal [1], ix.data
    end
  end
end
</file>

<file path="test/solace/instructions/spl_token/initialize_mint_instruction_test.rb">
# frozen_string_literal: true

require 'test_helper'

describe Solace::Instructions::SplToken::InitializeMintInstruction do
  describe 'build' do
    let(:decimals) { 6 }
    let(:mint_authority) { 'BvaC8MxEr1JQfoz4Ur4RybkcmL5QUKB57KjrvfL9DE64' }
    let(:freeze_authority) { nil }

    let(:mint_account_index) { 1 }
    let(:rent_sysvar_index) { 2 }
    let(:program_index) { 3 }

    let(:ix) do
      Solace::Instructions::SplToken::InitializeMintInstruction.build(
        decimals: decimals,
        mint_authority: mint_authority,
        freeze_authority: freeze_authority,
        mint_account_index: mint_account_index,
        rent_sysvar_index: rent_sysvar_index,
        program_index: program_index
      )
    end

    it 'should build a valid instruction' do
      assert_kind_of Solace::Instruction, ix
    end

    it 'should have the correct program index' do
      assert_equal program_index, ix.program_index
    end

    it 'should have the correct accounts' do
      assert_equal [mint_account_index, rent_sysvar_index], ix.accounts
    end

    describe 'with freeze authority' do
      let(:freeze_authority) { '8yfHvK7ZdcRQzjJ8KnT9xgceJbpiQjjuHcxqqHtdTNn6' }

      it 'should have the correct data' do
        assert_equal(
          [0, decimals] +
          Solace::Utils::Codecs.base58_to_bytes(mint_authority) +
          [1] +
          Solace::Utils::Codecs.base58_to_bytes(freeze_authority),
          ix.data
        )
      end
    end

    describe 'without freeze authority' do
      let(:freeze_authority) { nil }

      it 'should have the correct data' do
        assert_equal(
          [0, decimals] +
          Solace::Utils::Codecs.base58_to_bytes(mint_authority) +
          [0],
          ix.data
        )
      end
    end
  end
end
</file>

<file path="test/solace/instructions/spl_token/mint_to_instruction_test.rb">
# frozen_string_literal: true

require 'test_helper'

describe Solace::Instructions::SplToken::MintToInstruction do
  let(:connection) { Solace::Connection.new }

  describe '.build' do
    let(:ix) do
      Solace::Instructions::SplToken::MintToInstruction.build(
        amount: 1_000_000,
        mint_authority_index: 0,
        mint_index: 1,
        destination_index: 2,
        program_index: 3
      )
    end

    it 'should build a valid instruction' do
      assert_kind_of Solace::Instruction, ix
    end

    it 'should have the correct program index' do
      assert_equal 3, ix.program_index
    end

    it 'should have the correct accounts' do
      assert_equal [1, 2, 0], ix.accounts
    end

    it 'should have the correct data' do
      # 7 is the instruction index for mint_to
      # 1_000_000 is the amount in little-endian format
      assert_equal [7] + Solace::Utils::Codecs.encode_le_u64(1_000_000).bytes, ix.data
    end
  end

  describe 'on-chain test' do
    let(:owner) { Fixtures.load_keypair('bob') }
    let(:mint) { Fixtures.load_keypair('mint') }
    let(:payer) { Fixtures.load_keypair('payer') }
    let(:mint_authority) { Fixtures.load_keypair('mint-authority') }

    let(:amount) { 1_000_000_000 }

    before(:all) do
      # We need a token account to mint to, so we'll use the Associated Token Account program
      # to create one for the owner.
      ata_program = Solace::Programs::AssociatedTokenAccount.new(connection: connection)

      # Get the associated token account address
      @ata_address, = ata_program.get_address(owner: owner, mint: mint)

      accounts = [
        payer.address,
        mint_authority.address,
        mint.address,
        @ata_address,
        Solace::Constants::TOKEN_PROGRAM_ID
      ]

      # Now, mint to the newly created associated token account
      ix = Solace::Instructions::SplToken::MintToInstruction.build(
        amount: amount,
        mint_authority_index: 1,
        mint_index: 2,
        destination_index: 3,
        program_index: 4
      )

      message = Solace::Message.new(
        header: [
          2, # num_required_signatures
          0, # num_readonly_signed
          1  # num_readonly_unsigned
        ],
        accounts: accounts,
        instructions: [ix],
        recent_blockhash: connection.get_latest_blockhash
      )

      tx = Solace::Transaction.new(message: message)
      tx.sign(payer, mint_authority)

      # Send the transaction
      connection.wait_for_confirmed_signature do
        connection.send_transaction(tx.serialize)['result']
      end
    end

    it 'should have the correct token balance' do
      # TODO: fix this test to use a get token balance call
      balance = connection.get_account_info(@ata_address)

      data_binary = Base64.decode64(balance.dig('data', 0))
      amount_slice = data_binary.slice(64, 8)
      token_balance = amount_slice.unpack1('Q<')

      assert_operator amount, :<=, token_balance
    end
  end
end
</file>

<file path="test/solace/instructions/system_program/transfer_instruction_test.rb">
# frozen_string_literal: true

require 'test_helper'

describe Solace::Instructions::SystemProgram::TransferInstruction do
  describe '.build' do
    # Build a transfer instruction
    let(:ix) do
      Solace::Instructions::SystemProgram::TransferInstruction.build(
        to_index: 1,
        from_index: 0,
        program_index: 2,
        lamports: 100_000_000
      )
    end

    it 'returns an instruction' do
      assert_kind_of Solace::Instruction, ix
    end

    it 'sets the default program index' do
      assert_equal 2, ix.program_index
    end

    it 'has the correct accounts' do
      assert_equal [0, 1], ix.accounts
    end

    it 'has the correct data' do
      assert_equal [2, 0, 0, 0] + [100_000_000].pack('Q<').bytes, ix.data
    end

    describe 'with custom program index' do
      let(:ix_with_custom_program_index) do
        Solace::Instructions::SystemProgram::TransferInstruction.build(
          to_index: 0,
          from_index: 1,
          program_index: 3,
          lamports: 100_000
        )
      end

      it 'sets the custom program index' do
        assert_equal 3, ix_with_custom_program_index.program_index
      end
    end
  end
end
</file>

<file path="test/solace/programs/associated_token_account_test.rb">
# frozen_string_literal: true

require 'test_helper'

describe Solace::Programs::AssociatedTokenAccount do
  let(:klass) { Solace::Programs::AssociatedTokenAccount }
  let(:connection) { Solace::Connection.new }
  let(:program) { klass.new(connection: connection) }

  describe '#initialize' do
    it 'assigns connection' do
      assert_equal program.connection, connection
    end

    it 'assigns associated_token_account_program_id' do
      assert_equal program.program_id, Solace::Constants::ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID
    end
  end

  describe '.get_or_create_address' do
    let(:owner) { Solace::Keypair.generate }
    let(:mint) { Fixtures.load_keypair('mint') }
    let(:payer) { Fixtures.load_keypair('payer') }

    let(:ata_address) { program.get_address(owner: owner, mint: mint).first }
    let(:address_result) { program.get_or_create_address(payer: payer, owner: owner, mint: mint) }

    describe "when the owner doesn't have a token account" do
      it 'creates a new token account at the expected address' do
        assert connection.get_balance(ata_address).zero?
        assert connection.get_balance(address_result)
        assert_equal address_result, ata_address
      end
    end

    describe 'when the owner already has a token account' do
      it 'returns the associated token account address' do
        # Create the token account
        assert connection.get_balance(address_result)

        # Doesn't send any create transaction to the cluster
        def connection.send_transaction(_)
          raise "send_transaction shouldn't be called when a token account already exists."
        end

        # The token account should still exist
        assert connection.get_balance(address_result)
      end
    end
  end
end
</file>

<file path="test/solace/utils/codecs_test.rb">
# encoding: ASCII-8BIT
# frozen_string_literal: true

require 'test_helper'

describe Solace::Utils::Codecs do
  describe '#base64_to_bytestream' do
    it 'converts base64 string to bytestream' do
      stream = Solace::Utils::Codecs.base64_to_bytestream(
        "aXQgd29ya3M=\n" # base64 encoded "it works"
      )
      assert_equal 'it works', stream.read
    end
  end

  describe '#encode_compact_u16' do
    # Expected compact u16 values
    let(:valid_compact_u16_values) do
      {
        0 => "\x00".b,
        1 => "\x01".b,
        5 => "\x05".b,
        16 => "\x10".b,
        31 => "\x1f".b,
        63 => "\x3f".b,
        127 => "\x7f".b
      }
    end

    it 'encodes compact u16 values' do
      valid_compact_u16_values.each do |n, bytes|
        assert_equal(
          bytes,
          Solace::Utils::Codecs.encode_compact_u16(n),
          "Failed for n = #{n}, expected #{bytes} but got #{Solace::Utils::Codecs.encode_compact_u16(n).inspect}"
        )
      end
    end

    it 'decodes compact u16 values' do
      valid_compact_u16_values.each do |n, bytes|
        assert_equal(
          [n, bytes.length],
          Solace::Utils::Codecs.decode_compact_u16(StringIO.new(bytes)),
          "Failed for n = #{n}, expected #{bytes} but got #{Solace::Utils::Codecs.decode_compact_u16(StringIO.new(bytes)).inspect}"
        )
      end
    end
  end

  describe '#encode_le_u64' do
    # Expected little-endian U64 values
    let(:valid_le_u64_values) do
      {
        0 => "\x00\x00\x00\x00\x00\x00\x00\x00".b,
        1 => "\x01\x00\x00\x00\x00\x00\x00\x00".b,
        42 => "\x2a\x00\x00\x00\x00\x00\x00\x00".b,
        255 => "\xff\x00\x00\x00\x00\x00\x00\x00".b,
        256 => "\x00\x01\x00\x00\x00\x00\x00\x00".b,
        65_535 => "\xff\xff\x00\x00\x00\x00\x00\x00".b,
        4_294_967_295 => "\xff\xff\xff\xff\x00\x00\x00\x00".b,
        2**40 => "\x00\x00\x00\x00\x00\x01\x00\x00".b,
        2**63 => "\x00\x00\x00\x00\x00\x00\x00\x80".b
      }
    end

    it 'encodes little-endian u64 values' do
      valid_le_u64_values.each do |n, bytes|
        assert_equal(
          bytes,
          Solace::Utils::Codecs.encode_le_u64(n),
          "Failed for n = #{n}, expected #{bytes} but got #{Solace::Utils::Codecs.encode_le_u64(n).inspect}"
        )
      end
    end

    it 'decodes little-endian u64 values' do
      valid_le_u64_values.each do |n, bytes|
        assert_equal(
          n,
          Solace::Utils::Codecs.decode_le_u64(StringIO.new(bytes)),
          "Failed for n = #{n}, expected #{bytes} but got #{Solace::Utils::Codecs.decode_le_u64(StringIO.new(bytes)).inspect}"
        )
      end
    end
  end

  describe '#base58_to_bytes' do
    # Expected base58 values
    let(:valid_base58_mappings) do
      {
        '4k8k5d' => [146, 117, 191, 192],
        '11111111111111111111111111111111' => [0] * 32,
        'JxF12TrwUP45BMd' => [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100],
        '2VFAhjXBhMuEbmcTtjYXAZX4oVPhr3im7yb8RmaBofU6' => [22, 23, 247, 244, 154, 76, 30, 91, 94, 94, 164, 29, 134, 66,
                                                           178, 4, 193, 195, 140, 79, 197, 35, 89, 202, 7, 85, 64, 99, 10, 23, 242, 235]
      }
    end

    it 'encodes base58 values' do
      valid_base58_mappings.each do |base58, bytes|
        assert_equal(
          base58,
          Solace::Utils::Codecs.bytes_to_base58(bytes),
          "Failed for base58 = #{base58}, expected #{bytes} but got #{Solace::Utils::Codecs.bytes_to_base58(bytes).inspect}"
        )
      end
    end

    it 'decodes base58 values' do
      valid_base58_mappings.each do |base58, bytes|
        assert_equal(
          bytes,
          Solace::Utils::Codecs.base58_to_bytes(base58),
          "Failed for base58 = #{base58}, expected #{bytes} but got #{Solace::Utils::Codecs.base58_to_bytes(base58).inspect}"
        )
      end
    end
  end
end
</file>

<file path="test/solace/instruction_test.rb">
# frozen_string_literal: true

require_relative '../test_helper'

describe Solace::Instruction do
  let(:ix) { build(:instruction, :as_transfer) }

  describe '#serialize' do
    it 'returns a serialized instruction' do
      assert_kind_of String, ix.serialize
    end

    it 'has the correct structure' do
      assert_operator ix.serialize.bytesize, :>, 0
    end
  end

  describe '#deserialize' do
    before do
      @deserialized_ix = Solace::Instruction.deserialize(ix.to_io)
    end

    it 'deserializes into the same instruction' do
      assert_equal @deserialized_ix.program_index, 2
      assert_equal @deserialized_ix.accounts, [0, 1]
      assert_equal @deserialized_ix.data, ix.data
    end
  end
end
</file>

<file path="test/support/factory_bot.rb">
# frozen_string_literal: true

require 'factory_bot'

module Minitest
  class Test
    include FactoryBot::Syntax::Methods
  end
end

FactoryBot.definition_file_paths = [File.expand_path('../factories', __dir__)]
FactoryBot.find_definitions
</file>

<file path="test/support/fixtures.rb">
# frozen_string_literal: true

module Fixtures
  # Load a keypair fixture
  #
  # @param fixture_name [String] The name of the fixture file
  # @return [Solace::Keypair] The keypair object
  def self.load_keypair(fixture_name)
    Solace::Keypair.from_secret_key load(fixture_name).pack('C*')
  end

  # Loads a fixture file
  #
  # @param fixture_name [String] The name of the fixture file
  # @return [Array] The contents of the fixture file
  def self.load(fixture_name)
    JSON.load_file(File.expand_path("#{fixture_name}.json", path))
  end

  # Returns the path to the fixture directory
  def self.path
    File.expand_path('../fixtures', __dir__)
  end
end
</file>

<file path="test/support/solana_test_validator.rb">
# frozen_string_literal: true

# Spins up a Solana test validator before tests and tears it down after all tests have run.

SOLANA_VALIDATOR_CMD = 'solana-test-validator'
SOLANA_VALIDATOR_LOG = '/tmp/solana-test-validator.log'
SOLANA_VALIDATOR_ERR = '/tmp/solana-test-validator.err.log'

# If the validator is already running, return. This check will not
# work on certain systems, but it's better than nothing.
@validator_pid = `ps | grep 'solana-test-val'`.strip

return unless @validator_pid.empty?

@started_validator = true

# Spawn the validator in a child process
@solana_validator_pid = Process.spawn(
  SOLANA_VALIDATOR_CMD,
  out: SOLANA_VALIDATOR_LOG,
  err: SOLANA_VALIDATOR_ERR
)

puts "[SolanaTestValidator] Validator started on PID #{@solana_validator_pid}."

def validator_started?
  Solace::Connection.new.get_latest_blockhash
  true
rescue Errno::ECONNREFUSED
  false
end

until validator_started?
  puts '[SolanaTestValidator] Waiting for first blockhash...'
  sleep 1
end

# Stop the validator after all tests have run
Minitest.after_run do
  # Only if the validator was started by us should we stop it
  return unless @started_validator

  Process.kill('TERM', @solana_validator_pid)
  Process.wait(@solana_validator_pid)

  puts "\n[SolanaTestValidator] Validator stopped."
end
</file>

<file path="test/usecases/create_mint.rb">
# encoding: ASCII-8BIT
# frozen_string_literal: true

require 'base64'
require 'rbnacl'
require 'base58'
require 'stringio'

require 'test_helper'

# --- Script Execution ---

# 2. Setup
puts '--- Step 1: Setup ---'
# The payer is the account that will pay for the transaction fees and rent.
# It's loaded from fixtures in test_helper.rb
payer = Fixtures.load_keypair('payer')
puts "✅ Payer Account: #{payer.address}"

# A new keypair is generated for the new mint account. This account will hold
# information about the token, such as its supply and decimals.
mint_keypair = Solace::Keypair.generate
puts "✅ New Mint Account: #{mint_keypair.address}"

# The connection to the Solana cluster (devnet by default).
# It's loaded from test_helper.rb
conn = Solace::Connection.new
puts "✅ Connected to cluster: #{conn.rpc_url}"
puts "-----------------------\n"

# 3. Build Instructions
puts '--- Step 2: Building Instructions ---'
# We need the cost (in lamports) to make the new mint account rent-exempt.
# The size of a mint account is 82 bytes.
rent_lamports = conn.get_minimum_lamports_for_rent_exemption(82)
puts "✅ Rent for 82 bytes: #{rent_lamports} lamports"

# Instruction 1: Create a new account for the mint.
create_account_ix = Solace::Instructions::SystemProgram::CreateAccountInstruction.build(
  from_index: 0, # The payer is the first account
  new_account_index: 1, # The new mint is the second account
  system_program_index: 4, # The System Program is the fourth account
  lamports: rent_lamports,
  space: 82,
  owner: Solace::Constants::TOKEN_PROGRAM_ID
)
puts '✅ Built SystemProgram::CreateAccount instruction'

# Instruction 2: Initialize the new account as a mint.
initialize_mint_ix = Solace::Instructions::SplToken::InitializeMintInstruction.build(
  mint_account_index: 1, # The new mint is the second account
  rent_sysvar_index: 2, # The Rent Sysvar is the third account
  program_index: 3, # The SPL Token Program is the fourth account
  decimals: 6,
  mint_authority: payer.address # The payer will also be the mint authority
)
puts "\xE2\x9C\x85 Built SPLToken::InitializeMint instruction"
puts "-------------------------------------\n"

# 4. Build and Sign Transaction
puts '--- Step 3: Building and Signing Transaction ---'
# Create a new message and add the instructions.
message = Solace::Message.new(
  instructions: [create_account_ix, initialize_mint_ix],
  # Define all the accounts that will be used in the transaction.
  # Order matters for the instruction indices.
  accounts: [
    payer.address,
    mint_keypair.address,
    Solace::Constants::SYSVAR_RENT_PROGRAM_ID,
    Solace::Constants::TOKEN_PROGRAM_ID,
    Solace::Constants::SYSTEM_PROGRAM_ID
  ],
  # Set the message header now that we know the accounts.
  # Signers: payer (writable), mint_keypair (writable)
  # Read-only: Rent Sysvar, SPL Token Program, System Program
  header: [2, 0, 3],
  recent_blockhash: conn.get_latest_blockhash
)
puts '✅ Assembled message'

# Create the transaction with the message.
tx = Solace::Transaction.new(message: message)

# Sign the transaction with the required keypairs.
# The payer signs to authorize the lamport transfer.
# The mint_keypair signs because it's a new account being created.
tx.sign(payer, mint_keypair)
puts '✅ Signed transaction with payer and mint keypair'
puts "----------------------------------------------\n"

# 5. Send and Confirm Transaction
puts '--- Step 4: Sending Transaction ---'
signature = nil

# Serialize the transaction and send it to the cluster.
# Wait for the transaction to be confirmed.
conn.wait_for_confirmed_signature do
  signature = conn.send_transaction(tx.serialize)['result']
end

puts "\xE2\x9C\x85 Transaction confirmed!"
puts "View on Solana Explorer: https://explorer.solana.com/tx/#{signature}?cluster=devnet"
puts "---------------------------------\n"
</file>

<file path="test/usecases/get_transaction.rb">
# frozen_string_literal: true

require 'test_helper'

# =============================
# 🧩 Get Transaction
# =============================
signature = '4yEs446FfgW5VZKa3GW4Ss1o19MUmE9QTqFnSpE3m96nbownfQh8RPvinj3batwVPwRsr2CcN7ipUJc8QypD2fgC'

response = Solace::Connection.new('https://api.mainnet-beta.solana.com').get_transaction(signature)

puts 'Response:'
puts response
</file>

<file path="test/usecases/legacy_transfer.rb">
# frozen_string_literal: true

# =============================
# 🧾 Solana Manual SOL Transfer (Ruby)
# =============================
# This script demonstrates:
# - Building a Solana system transfer instruction (transfer SOL)
# - Serializing the full transaction manually
# - Signing with Ed25519 using RbNaCl
# - Posting to a local Solana validator via RPC

require 'uri'
require 'json'
require 'rbnacl'
require 'base64'
require 'net/http'

require 'test_helper'

Codecs = Solace::Utils::Codecs

connection = Solace::Connection.new

# =============================
# 🧩 Get latest blockhash
# =============================
blockhash = connection.get_latest_blockhash

# =============================
# 🔐 Key Setup
# =============================
bob_path = File.expand_path('../fixtures/bob.json', __dir__)
anna_path = File.expand_path('../fixtures/anna.json', __dir__)

# Bob (sender)
bob_sk_bytes = JSON.load_file(bob_path)
bob_keypair = RbNaCl::Signatures::Ed25519::SigningKey.new(bob_sk_bytes[0, 32].pack('C*'))
bob_pubkey = bob_keypair.verify_key.to_bytes

# Anna (receiver)
anna_sk_bytes = JSON.load_file(anna_path)
anna_pubkey = anna_sk_bytes[32, 32].pack('C*')

# Program ID: System Program (111111...)
#
# Many base58 decoders mis-handle the deserialization of the
# base58 string "11111111111111111111111111111111", outputting byte sequence
# of 32 * 0x00 (32 bytes of 0s) instead of 31 * 0xFF + 0x01 (31 bytes of 0s and 1).
# If receiving a program not found error, check the system program ID.
system_program = Base58.base58_to_binary('11111111111111111111111111111111')

# =============================
# 🧩 Account Setup
# =============================

# All accounts needed for the transaction
accounts = [
  bob_pubkey,
  anna_pubkey,
  system_program
].join

# =============================
# 📦 Build Instruction: System Transfer
# =============================

# Instruction layout:
# - program_id_index = 2
# - accounts = [
#   0 (bob),
#   1 (anna)
# ]
# - data = 4-byte instruction ID + u64 amount (LE)

instruction_data =
  [2, 0, 0, 0] + # instruction ID = 2 (System Transfer)
  Codecs.encode_le_u64(1_000_000).bytes # transferring 0.001 SOL

instruction = [
  [2].pack('C'),                                          # program ID index
  Codecs.encode_compact_u16(2),                           # num accounts
  [
    0,                                                    # bob account index
    1                                                     # anna account index
  ].pack('C*'),                                           # account indices: bob, anna
  Codecs.encode_compact_u16(instruction_data.length),     # instruction data length
  instruction_data.pack('C*')                             # instruction data
].join

# =============================
# 🧱 Build Message
# =============================

header = [
  1, # numRequiredSignatures
  0, # numReadonlySignedAccounts
  1  # numReadonlyUnsignedAccounts (system program)
].pack('C*')

# =============================
# 🧩 Get latest blockhash
# =============================
recent_blockhash = Codecs.base58_to_bytes(blockhash).pack('C*')

message = [
  header,
  Codecs.encode_compact_u16(3), # num account keys
  accounts, # account keys
  recent_blockhash, # recent blockhash
  Codecs.encode_compact_u16(1), # number of instructions
  instruction # instruction
].join

# =============================
# ✍️ Sign Message
# =============================
signature = bob_keypair.sign(message)

# =============================
# 🧾 Final Transaction
# =============================
transaction = [
  Codecs.encode_compact_u16(1), # number of signatures
  signature,
  message
].join

base64_tx = Base64.strict_encode64(transaction)
puts "Transaction: #{base64_tx}"

# =============================
# 🚀 Send via RPC to Local Validator
# =============================

result = connection.send_transaction(base64_tx)

puts 'Response:'
puts result
</file>

<file path="test/usecases/test_initialize_mint_instruction.rb">
# frozen_string_literal: true

# test_token_transfer_sdk.rb

require 'test_helper'
require 'base58'

mint_authority_keypair = Fixtures.load_keypair('mint-authority')

conn = Solace::Connection.new

conn.wait_for_confirmed_signature do
  puts 'Funding Mint Authority...'
  conn.request_airdrop(mint_authority_keypair.address, 10_000_000_000)['result']
end

mint_keypair = Solace::Keypair.generate

# 5. Build SPL token transfer instruction
instruction = Solace::Instructions::SplToken::InitializeMintInstruction.build(
  decimals: 6,
  mint_authority: mint_authority_keypair.public_key_bytes,
  rent_sysvar_index: 1,
  mint_account_index: 0,
  program_index: 2
)

# 6. Build transaction
accounts = [
  mint_keypair.address,
  Solace::Constants::SYSVAR_RENT_PROGRAM_ID,
  Solace::Constants::TOKEN_PROGRAM_ID
]

message = Solace::Message.new(
  header: [
    1, # num_required_signatures
    0, # num_readonly_signed
    2 # num_readonly_unsigned
  ],
  accounts: accounts,
  recent_blockhash: conn.get_latest_blockhash,
  instructions: [instruction]
)

# 7. Build transaction
transaction = Solace::Transaction.new(message: message)
transaction.sign(mint_keypair)

# 8. Send transaction
result = conn.send_transaction(transaction.serialize)
puts "Token transfer transaction sent: #{result}"
</file>

<file path="test/usecases/versioned_transfer.rb">
# frozen_string_literal: true

# =============================
# 🧾 Solana Manual SOL Transfer (Ruby)
# =============================
# This script demonstrates:
# - Building a Solana system transfer instruction (transfer SOL)
# - Serializing the full transaction manually
# - Signing with Ed25519 using RbNaCl
# - Posting to a local Solana validator via RPC

require 'uri'
require 'json'
require 'rbnacl'
require 'base64'

require 'test_helper'

Codecs = Solace::Utils::Codecs

connection = Solace::Connection.new

# =============================
# 🧩 Get latest blockhash
# =============================
recent_blockhash = connection.get_latest_blockhash

# =============================
# 🔐 Key Setup
# =============================
bob_path = File.expand_path('../fixtures/bob.json', __dir__)
anna_path = File.expand_path('../fixtures/anna.json', __dir__)

# Bob (sender)
bob_sk_bytes = JSON.load_file(bob_path)
bob_keypair = RbNaCl::Signatures::Ed25519::SigningKey.new(bob_sk_bytes[0, 32].pack('C*'))
bob_pubkey = bob_keypair.verify_key.to_bytes
bob_address = Codecs.binary_to_base58(bob_pubkey)

# Anna (receiver)
anna_sk_bytes = JSON.load_file(anna_path)
anna_pubkey = anna_sk_bytes[32, 32].pack('C*')
anna_address = Codecs.binary_to_base58(anna_pubkey)

# Show starting balances
bob_balance = connection.get_balance(bob_address)
anna_balance = connection.get_balance(anna_address)

puts "Bob balance: #{bob_balance} lamports"
puts "Anna balance: #{anna_balance} lamports"

`solana airdrop 1 #{bob_address}` if bob_balance.zero?

# Program ID: System Program (111111...)
#
# Many base58 decoders mis-handle the deserialization of the
# base58 string "11111111111111111111111111111111", outputting byte sequence
# of 32 * 0x00 (32 bytes of 0s) instead of 31 * 0xFF + 0x01 (31 bytes of 0s and 1).
# If receiving a program not found error, check the system program ID.
system_program = Base58.base58_to_binary('11111111111111111111111111111111')

# =============================
# 🧩 Account Setup
# =============================

# All accounts needed for the transaction
accounts = [
  bob_pubkey,
  anna_pubkey,
  system_program
].join

# =============================
# 📦 Build Instruction: System Transfer
# =============================

# Instruction layout:
# - program_id_index = 2
# - accounts = [
#   0 (bob),
#   1 (anna)
# ]
# - data = 4-byte instruction ID + u64 amount (LE)

instruction_data =
  [2, 0, 0, 0] + # instruction ID = 2 (System Transfer)
  Codecs.encode_le_u64(1_000_000).bytes # transferring 0.001 SOL

instruction = [
  [2].pack('C'), # program ID index
  Codecs.encode_compact_u16(2), # num accounts
  [
    0,                                                    # bob account index
    1                                                     # anna account index
  ].pack('C*'),                                           # account indices: bob, anna
  Codecs.encode_compact_u16(instruction_data.length), # instruction data length
  instruction_data.pack('C*') # instruction data
].join

# =============================
# 🧱 Build Message
# =============================

header = [
  1, # numRequiredSignatures
  0, # numReadonlySignedAccounts
  1  # numReadonlyUnsignedAccounts (system program)
].pack('C*')

# =============================
# 🧩 Get latest blockhash
# =============================
recent_blockhash = Codecs.base58_to_bytes(recent_blockhash).pack('C*')

# =============================
# 🧩 Build a Versioned Message (V0)
# =============================
VERSION_PREFIX = "\x80".b

# Address Table Lookup: empty for minimal versioned transaction
address_table_lookup = [
  Codecs.encode_compact_u16(0) # num addresses
].join

versioned_message = [
  VERSION_PREFIX,
  header,
  Codecs.encode_compact_u16(3),       # num account keys
  accounts,                           # account keys
  recent_blockhash,                   # recent blockhash
  Codecs.encode_compact_u16(1),       # number of instructions
  instruction,                        # instruction
  address_table_lookup
].join

# =============================
# ✍️ Sign Message
# =============================
signature = bob_keypair.sign(versioned_message)

# =============================
# 🧾 Final Transaction
# =============================
transaction = [
  Codecs.encode_compact_u16(1), # number of signatures
  signature,
  versioned_message
].join

base64_tx = Base64.strict_encode64(transaction)
puts "Transaction: #{base64_tx}"

# =============================
# 🚀 Send via RPC to Local Validator
# =============================
result = connection.send_transaction(base64_tx)

puts 'Response:'
puts result
</file>

<file path="lib/solace/composers/associated_token_account_program_create_account_composer.rb">
# frozen_string_literal: true

module Solace
  module Composers
    # Composer for creating an associated token account program create account instruction
    #
    # This composer resolves and orders the required accounts for a `CreateAssociatedTokenAccount` instruction,
    # sets up their access permissions, and delegates construction to the appropriate
    # instruction builder (`Instructions::AssociatedTokenAccount::CreateAssociatedTokenAccountInstruction`).
    #
    # Required accounts:
    # - **Funder**: the account that will pay for fees and rent.
    # - **Owner**: the account that will own the new ATA.
    # - **ATA**: the address of the new ATA.
    # - **Mint**: the mint address of the token.
    # - **System Program**: the system program id.
    # - **Token Program**: the token program id.
    # - **Associated Token Account Program**: the associated token account program id.
    #
    # @example Compose and build a create account instruction
    #   composer = AssociatedTokenAccountProgramCreateAccountComposer.new(
    #     funder: funder_address,
    #     owner: owner_address,
    #     ata_address: ata_address,
    #     mint: mint_address
    #   )
    #
    # @see Instructions::AssociatedTokenAccount::CreateAssociatedTokenAccountInstruction
    # @since 0.0.7
    class AssociatedTokenAccountProgramCreateAccountComposer < Base
      # Extracts the owner address from the params
      #
      # @return [String] The owner address
      def owner
        params[:owner].to_s
      end

      # Extracts the mint address from the params
      #
      # @return [String] The mint address
      def mint
        params[:mint].to_s
      end

      # Extracts the ata_address from the params
      #
      # @return [String] The ata_address
      def ata_address
        params[:ata_address].to_s
      end

      # Extracts the funder address from the params
      #
      # @return [String] The funder address
      def funder
        params[:funder].to_s
      end

      # Extracts the system program id from the constants
      #
      # @return [String] The system program id
      def system_program_id
        Constants::SYSTEM_PROGRAM_ID.to_s
      end

      # Extracts the token program id from the constants
      #
      # @return [String] The token program id
      def token_program_id
        Constants::TOKEN_PROGRAM_ID.to_s
      end

      # Extracts the associated token account program id from the constants
      #
      # @return [String] The associated token account program id
      def associated_token_account_program_id
        Constants::ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID.to_s
      end

      # Setup accounts required for associated token account program create account instruction
      # Called automatically during initialization
      #
      # @return [void]
      def setup_accounts # rubocop:disable Metrics/AbcSize
        account_context.add_writable_signer(funder)
        account_context.add_writable_nonsigner(ata_address)
        account_context.add_readonly_nonsigner(owner)
        account_context.add_readonly_nonsigner(mint)
        account_context.add_readonly_nonsigner(system_program_id)
        account_context.add_readonly_nonsigner(token_program_id)
        account_context.add_readonly_nonsigner(associated_token_account_program_id)
      end

      # Builds the instruction for the associated token account program create account instruction
      #
      # @param account_context [Utils::AccountContext] The account context
      # @return [Solace::Instruction] The instruction
      def build_instruction(account_context)
        Instructions::AssociatedTokenAccount::CreateAssociatedTokenAccountInstruction.build(
          funder_index: account_context.index_of(funder),
          owner_index: account_context.index_of(owner),
          mint_index: account_context.index_of(mint),
          associated_token_account_index: account_context.index_of(ata_address),
          system_program_index: account_context.index_of(system_program_id),
          token_program_index: account_context.index_of(token_program_id),
          program_index: account_context.index_of(associated_token_account_program_id)
        )
      end
    end
  end
end
</file>

<file path="lib/solace/instructions/spl_token/mint_to_instruction.rb">
# frozen_string_literal: true

module Solace
  module Instructions
    module SplToken
      # Instruction for minting tokens to a token account.
      #
      # This instruction is used to mint tokens to a token account for a given mint and owner.
      #
      # @example Build a MintTo instruction
      #   instruction = Solace::Instructions::SplToken::MintToInstruction.build(
      #     amount: 100,
      #     mint_index: 1,
      #     mint_authority_index: 2,
      #     destination_index: 3,
      #     program_index: 4
      #   )
      #
      # @since 0.0.2
      class MintToInstruction
        # @!attribute [Array<Integer>] INSTRUCTION_INDEX
        #   Instruction index for SPL Token Program's MintTo instruction.
        INSTRUCTION_INDEX = [7].freeze

        # Builds a MintTo instruction.
        #
        # @param amount [Integer] The amount of tokens to mint.
        # @param mint_index [Integer] The index of the mint account.
        # @param destination_index [Integer] The index of the token account to mint to.
        # @param mint_authority_index [Integer] The index of the mint authority account.
        # @param program_index [Integer] The index of the SPL Token Program.
        # @return [Solace::Instruction]
        def self.build(
          amount:,
          mint_index:,
          mint_authority_index:,
          destination_index:,
          program_index:
        )
          Solace::Instruction.new.tap do |ix|
            ix.program_index = program_index
            ix.accounts = [mint_index, destination_index, mint_authority_index]
            ix.data = data(amount)
          end
        end

        # Builds the data for a MintTo instruction.
        #
        # The BufferLayout is:
        #   - [Instruction Index (1 byte)]
        #   - [Amount (8 bytes)]
        #
        # @param amount [Integer] The amount of tokens to mint.
        # @return [Array] 1-byte instruction index + 8-byte amount
        def self.data(amount)
          INSTRUCTION_INDEX + Solace::Utils::Codecs.encode_le_u64(amount).bytes
        end
      end
    end
  end
end
</file>

<file path="lib/solace/programs/base.rb">
# frozen_string_literal: true

# lib/solace/programs/base.rb

module Solace
  module Programs
    # Base class for program-specific clients.
    #
    # Provides a consistent interface for interacting with on-chain programs.
    #
    # @abstract
    # @see Solace::Programs::SplToken
    # @see Solace::Programs::AssociatedTokenAccount
    # @since 0.0.2
    class Base
      attr_reader :connection, :program_id

      # Initializes a new program client.
      #
      # @param connection [Solace::Connection] The connection to the Solana cluster.
      # @param program_id [String] The base58 public key of the on-chain program.
      def initialize(connection:, program_id:)
        @connection = connection
        @program_id = program_id
      end
    end
  end
end
</file>

<file path="test/factories/message_factory.rb">
# frozen_string_literal: true

require 'factory_bot'

FactoryBot.define do
  factory :message, class: 'Solace::Message' do
    version { nil }
    header { [0, 0, 0] }
    accounts { [] }
    recent_blockhash { nil }
    instructions { [] }
    address_lookup_tables { [] }
  end

  factory :versioned_message, parent: :message do
    version { 0 }
  end

  factory :legacy_message, parent: :message do
    version { nil }
  end

  trait :with_transfer_instruction do
    # Header
    header do
      [
        1, # num_required_signatures
        0, # num_readonly_signed
        1  # num_readonly_unsigned
      ]
    end

    # Accounts
    accounts do
      [
        '2VFAhjXBhMuEbmcTtjYXAZX4oVPhr3im7yb8RmaBofU6',
        'cbk37cQDdSqarxFTD9oG9c31YhcGZzd2QJwuGmWZhLL',
        Solace::Constants::SYSTEM_PROGRAM_ID
      ]
    end

    # Recent blockhash
    recent_blockhash { '9s5BVd3xd3MinQcJbCCTBwXn6WRukcdEwgC2ZjktjKqu' }

    # Transfer instruction
    instructions do
      [
        Solace::Instructions::SystemProgram::TransferInstruction.build(
          to_index: 1,
          from_index: 0,
          program_index: 2,
          lamports: 10_000_000 # 0.01 SOL
        )
      ]
    end
  end
end
</file>

<file path="test/factories/transaction_factory.rb">
# frozen_string_literal: true

require 'factory_bot'

FactoryBot.define do
  factory :transaction, class: 'Solace::Transaction' do
    signatures { [] }
    message { nil }

    trait :with_legacy_transfer do
      message { build(:legacy_message, :with_transfer_instruction) }
    end

    trait :with_versioned_transfer do
      message { build(:versioned_message, :with_transfer_instruction) }
    end
  end
end
</file>

<file path="test/solace/programs/base_test.rb">
# frozen_string_literal: true

require 'test_helper'

describe Solace::Programs::Base do
  let(:klass) { Solace::Programs::Base }

  let(:connection) { Solace::Connection.new }
  let(:program_id) { '11111111111111111111111111111111' }

  describe '#initialize' do
    subject { klass.new(connection: connection, program_id: program_id) }

    it 'assigns connection' do
      assert_equal subject.connection, connection
    end

    it 'assigns program_id' do
      assert_equal subject.program_id, program_id
    end
  end
end
</file>

<file path="test/solace/serializers/message_deserializer_test.rb">
# frozen_string_literal: true

require_relative '../../test_helper'

describe Solace::Serializers::MessageDeserializer do
  describe '#call' do
    describe 'legacy message' do
      let(:msg) { build(:legacy_message, :with_transfer_instruction) }

      before do
        @msg = Solace::Serializers::MessageDeserializer.new(msg.to_io).call
      end

      it 'does not extract version' do
        refute @msg.versioned?
        assert_nil @msg.version
      end

      it 'extracts accounts' do
        assert_equal 3, @msg.accounts.size
      end

      it 'extracts instructions' do
        assert_equal 1, @msg.instructions.size
      end

      it 'extracts message header' do
        assert_equal [1, 0, 1], @msg.header
      end

      it 'extracts recent blockhash' do
        assert_kind_of String, @msg.recent_blockhash
      end
    end

    describe 'versioned message' do
      let(:msg) { build(:versioned_message, :with_transfer_instruction) }

      before do
        @msg = Solace::Serializers::MessageDeserializer.new(msg.to_io).call
      end

      it 'extracts version' do
        assert @msg.versioned?
        assert_equal 0, @msg.version
      end

      it 'extracts accounts' do
        assert_equal 3, @msg.accounts.size
      end

      it 'extracts instructions' do
        assert_equal 1, @msg.instructions.size
      end

      it 'extracts message header' do
        assert_equal [1, 0, 1], @msg.header
      end

      it 'extracts recent blockhash' do
        assert_kind_of String, @msg.recent_blockhash
      end

      it 'extracts address lookup table' do
        assert_equal 0, @msg.address_lookup_tables.size
      end
    end
  end
end
</file>

<file path="test/solace/serializers/message_serializer_test.rb">
# frozen_string_literal: true

require_relative '../../test_helper'

describe Solace::Serializers::MessageSerializer do
  describe '#call' do
    describe 'legacy message' do
      let(:msg) { build(:legacy_message, :with_transfer_instruction) }

      before do
        @serialized_msg = Solace::Serializers::MessageSerializer.new(msg).call
      end

      it 'returns a valid binary string' do
        assert @serialized_msg.valid_encoding?
      end

      it 'has the correct structure' do
        assert_operator @serialized_msg.bytesize, :>, 0
      end

      it 'raises if blockhash is missing' do
        msg = build(:legacy_message, :with_transfer_instruction, recent_blockhash: nil)

        assert_raises(RuntimeError) do
          Solace::Serializers::MessageSerializer.new(msg).call
        end
      end
    end

    describe 'versioned message' do
      let(:msg) { build(:versioned_message, :with_transfer_instruction) }

      before do
        @serialized_msg = Solace::Serializers::MessageSerializer.new(msg).call
      end

      it 'returns a valid binary string' do
        assert @serialized_msg.valid_encoding?
      end

      it 'has the correct structure' do
        assert_operator @serialized_msg.bytesize, :>, 0
      end
    end
  end
end
</file>

<file path="test/solace/serializers/transaction_deserializer_test.rb">
# frozen_string_literal: true

require_relative '../../test_helper'

describe Solace::Serializers::TransactionDeserializer do
  describe '#call' do
    describe 'legacy transaction' do
      let(:legacy_tx_io) do
        Solace::Utils::Codecs.base64_to_bytestream('ATb9iy8YGDhu3n/lblX6vutFwL08V2vO6SWM0tzvXyYKfkl+JHJ+Ne3LQL2ST3bFz+yq8WKY6xRl1gT6Hl7OfwABAAEDFhf39JpMHlteXqQdhkKyBMHDjE/FI1nKB1VAYwoX8usJHpx5omCOgQLd62o8TZKcoP4rwMXr3VxZW7WY5RVdEQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAApnfy5i7sTd9C9sheZ1m39A4THe+MBUS0Mg0CR0ElXsIBAgIAAQwCAAAAQEIPAAAAAAA=')
      end

      before do
        @tx = Solace::Serializers::TransactionDeserializer.new(legacy_tx_io).call
      end

      it 'returns a transaction' do
        assert_kind_of Solace::Transaction, @tx
      end

      it 'extracts signatures' do
        assert_equal 1, @tx.signatures.size
      end

      it 'extracts message' do
        assert_kind_of Solace::Message, @tx.message
      end
    end

    describe 'versioned transaction' do
      let(:versioned_tx_io) do
        Solace::Utils::Codecs.base64_to_bytestream('Acgu9eEm+Vemca/5lLQJbSJYa0YvkB5bGYafvo4thl6lHNYsSAG7sVh4KAX+k2zPl1gf4zd0Yd9Ds+UVOkIhvwWAAQAEDpkYZngZ374Y0pb6toNS8GHchmk84eLPpT4FJYf5crqomSd1qmAcQwzxZ+k/CeilJsmeji0PQ1cYjpPgihQaOIWIBErEGNasI3hrll4pKZsGHXknGG0+wErI4I5gt02GfJYlqLPaiX4sQV4FMW9kLNv5yW7ehfQRK8XbAqgyNWMlNf7CHxePVFUrXDi1BMb/4ybhol6hmYY5qaC5PldZqTEtApC6Uq9mdQdfYV0bL+7LTUAhN/sLOh2FVZeB3rqseUgWJ/Wlr2SJc6B3X4zsauwJo1l30cYqGje+BVlW8rQ+2mxPsy/Mq5zYLYsZPpxwGo2Mf6HYD38wsqhDpTRfMvb5Cbin+fF73r0gMfSNlfSaAnV+fOpSFHPQN5Yq0KXSELfiD4hBX0flO2syRT6ZYt+fhAzZmL93ET+6qG9NydzRAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBkZv5SEXMv/srbpyw5vnvIzlu8X3EmssQ5s6QAAAAMKC3ZljbddWFnVt++HEh8V+9bue8NoWVHq2eCijyFuLBHnVLe2/a8Xs0J2EU0o0rqWXUEOzb9ArJGULtYRDWVwqyfBc4wPKEDwZ+J83/G1LSd0aTRUzQ+x3nDrAPv64oQQLAAkDAQAAAAAAAAALAAUCY2sOAA05IwAgMS8eLSwdHAggAAggADAKIzIuIiMAEB8OCA8BAQEkIiMAGQIaHxsHBwcrIiMABAIJIAUDBgYMLOUXy5d6460qAAQAAAACFwACEQACEQACEQEfdAAAAAAAAB90AAAAAAAAAAAADRkjAB8mIyclAB8TEiEUESgjKikAIRgXHxYVJOUXy5d6460qAAIAAAACAwIDRzkeAAAAAABHOR4AAAAAAAAAAAZeksiuGUD29Evnx5+b5Awe13wncsSmQU2U1qFnaqfiWANrbJoDbQRpB8dTfmoXCYp/6NAuhjfAkYGFdrwum0jfX4IP+UDTmQwExMbFwwPKyMc9eI6loMOfhEUBficrajwPaSQFTUllI+ZuBSUzy0HtbARQT05NA0lMS9LDB68Y9BoPcKBD37erv38IqCugyHrQuvRdzSVNl2UNA9nd4AHhO9l9gy3odcj1w3FZTmZWYdQ2gP9C6xGhBBeyH+n2swMDW1pXB15YYVZfXGMpc7pKAgpBMfko96SFVmoW5yI6moN3eGQnlJmiZwZQLAOgkUoA')
      end

      before do
        @tx = Solace::Serializers::TransactionDeserializer.new(versioned_tx_io).call
      end

      it 'returns a transaction' do
        assert_kind_of Solace::Transaction, @tx
      end

      it 'extracts signatures' do
        assert_equal 1, @tx.signatures.size
      end

      it 'extracts message' do
        assert_kind_of Solace::Message, @tx.message
      end
    end
  end
end
</file>

<file path="test/solace/serializers/transaction_serializer_test.rb">
# frozen_string_literal: true

require_relative '../../test_helper'

describe Solace::Serializers::TransactionSerializer do
  describe '#call' do
    describe 'legacy transaction' do
      let(:tx) { build(:transaction, :with_legacy_transfer) }

      before do
        @serialized_tx = Solace::Serializers::TransactionSerializer.new(tx).call
      end

      it 'returns a valid binary string' do
        assert @serialized_tx.valid_encoding?
      end

      it 'has the correct structure' do
        assert_operator @serialized_tx.bytesize, :>, 0
      end
    end

    describe 'versioned transaction' do
      let(:tx) { build(:transaction, :with_versioned_transfer) }

      before do
        @serialized_tx = Solace::Serializers::TransactionSerializer.new(tx).call
      end

      it 'returns a valid binary string' do
        assert @serialized_tx.valid_encoding?
      end

      it 'has the correct structure' do
        assert_operator @serialized_tx.bytesize, :>, 0
      end
    end
  end
end
</file>

<file path="test/solace/message_test.rb">
# frozen_string_literal: true

require_relative '../test_helper'

describe Solace::Message do
  describe '#serialize' do
    before do
      @msg = Solace::Message.new(
        header: [1, 0, 1],
        accounts: [
          '2VFAhjXBhMuEbmcTtjYXAZX4oVPhr3im7yb8RmaBofU6',
          'cbk37cQDdSqarxFTD9oG9c31YhcGZzd2QJwuGmWZhLL',
          Solace::Constants::SYSTEM_PROGRAM_ID
        ],
        recent_blockhash: '9s5BVd3xd3MinQcJbCCTBwXn6WRukcdEwgC2ZjktjKqu',
        instructions: [
          Solace::Instructions::SystemProgram::TransferInstruction.build(
            to_index: 1,
            from_index: 0,
            program_index: 2,
            lamports: 1_000_000
          )
        ]
      )
    end

    it 'returns serialized legacy message' do
      assert_kind_of String, @msg.serialize
    end

    it 'has the correct structure' do
      assert_operator @msg.serialize.bytesize, :>, 0
    end

    describe '#versioned?' do
      it 'returns false for legacy message' do
        @msg.version = nil

        refute @msg.versioned?
      end

      it 'returns true for versioned message' do
        @msg.version = 0

        assert @msg.versioned?
      end
    end
  end
end
</file>

<file path="test/solace/transaction_composer_test.rb">
# frozen_string_literal: true

require 'test_helper'

describe Solace::TransactionComposer do
  let(:connection) { Solace::Connection.new }
  let(:composer) { Solace::TransactionComposer.new(connection: connection) }

  # Mint
  let(:mint_keypair) { Fixtures.load_keypair('mint') }
  let(:mint_authority) { Fixtures.load_keypair('mint_authority') }
  let(:freeze_authority) { Fixtures.load_keypair('freeze_authority') }

  # Test keypairs
  let(:random_keypair) { Solace::Keypair.generate }
  let(:bob_keypair) { Fixtures.load_keypair('bob') }
  let(:anna_keypair) { Fixtures.load_keypair('anna') }
  let(:payer_keypair) { Fixtures.load_keypair('payer') }

  # Test atas
  let(:bob_ata) { Solace::Programs::AssociatedTokenAccount.get_address(owner: bob_keypair, mint: anna_keypair) }
  let(:anna_ata) { Solace::Programs::AssociatedTokenAccount.get_address(owner: anna_keypair, mint: anna_keypair) }

  # Test programs
  let(:system_program) { Solace::Constants::SYSTEM_PROGRAM_ID }
  let(:spl_token_program) { Solace::Constants::SPL_TOKEN_PROGRAM_ID }

  # Test composers
  let(:transfer_composer1) do
    Solace::Composers::SystemProgramTransferComposer.new(
      from: anna_keypair,
      to: bob_keypair,
      lamports: 1000
    )
  end

  let(:transfer_composer2) do
    Solace::Composers::SystemProgramTransferComposer.new(
      from: bob_keypair,
      to: random_keypair,
      lamports: 2000
    )
  end

  describe '#initialize' do
    it 'creates a new composer with connection' do
      assert_equal connection, composer.connection
    end

    it 'has a instruction composers array' do
      assert_equal [], composer.instruction_composers
    end

    it 'has a transaction context (account context)' do
      assert_instance_of Solace::Utils::AccountContext, composer.context
    end
  end

  describe '#add_instruction' do
    it 'adds instruction composer and returns self for chaining' do
      result = composer.add_instruction(transfer_composer1)

      assert_equal composer, result
      assert_equal 1, composer.instruction_composers.length
      assert_equal transfer_composer1, composer.instruction_composers.first
    end

    it 'merges accounts from instruction composer into transaction context' do
      composer.add_instruction(transfer_composer1)

      tx_context = composer.context

      # Verify accounts are present using predicate methods
      assert tx_context.signer?(anna_keypair.address)
      assert tx_context.writable?(anna_keypair.address)
      assert tx_context.writable_signer?(anna_keypair.address)

      assert tx_context.writable?(bob_keypair.address)
      refute tx_context.signer?(bob_keypair.address)
      assert tx_context.writable_nonsigner?(bob_keypair.address)

      assert tx_context.readonly_nonsigner?(system_program)
    end

    it 'handles multiple instruction composers with account deduplication' do
      composer
        .add_instruction(transfer_composer1)
        .add_instruction(transfer_composer2)

      assert_equal 2, composer.instruction_composers.length

      tx_context = composer.context

      # Anna should be a signer (from transfer_composer1)
      assert tx_context.writable_signer?(anna_keypair.address)

      # Bob should be writable (appears in both transfers)
      assert tx_context.writable?(bob_keypair.address)

      # Random should be writable (from transfer_composer2)
      assert tx_context.writable_nonsigner?(random_keypair.address)

      # System program should be readonly
      assert tx_context.readonly_nonsigner?(system_program)
    end
  end

  describe '#set_fee_payer' do
    it 'sets fee payer and returns self for chaining' do
      result = composer.set_fee_payer(payer_keypair)

      assert_equal composer, result
      assert composer.context.fee_payer?(payer_keypair.address)
    end
  end

  describe '#compose_transaction' do
    before do
      # Mock connection to return a blockhash
      def connection.get_latest_blockhash
        'EkSnNWid2cvwEVnVx9aBqawnmiCNiDgp3gUdkDPTKN1N'
      end
    end

    it 'composes a single instruction transaction' do
      composer.add_instruction(transfer_composer1)
      composer.set_fee_payer(payer_keypair)

      tx = composer.compose_transaction

      assert_instance_of Solace::Transaction, tx
      assert_instance_of Solace::Message, tx.message
      assert_equal 1, tx.message.instructions.length

      # Verify accounts are in correct order (fee payer first, then signers, then others)
      accounts = tx.message.accounts
      assert_equal payer_keypair.address, accounts[0]  # Fee payer first
      assert_equal anna_keypair.address, accounts[1]   # From account (signer)

      # Verify header
      header = tx.message.header
      assert_equal 2, header[0] # 2 writable signers (fee_payer + from)

      # Verify instruction
      instruction = tx.message.instructions.first
      assert_instance_of Solace::Instruction, instruction
    end

    it 'composes multi-instruction transaction with account deduplication' do
      composer.add_instruction(transfer_composer1)
      composer.add_instruction(transfer_composer2)
      composer.set_fee_payer(anna_keypair) # Same as from in first transfer

      tx = composer.compose_transaction

      assert_instance_of Solace::Transaction, tx
      assert_equal 2, tx.message.instructions.length

      # Anna should appear only once in accounts despite being fee payer and from account
      accounts = tx.message.accounts

      anna_count = accounts.count { |addr| addr == anna_keypair.address }
      assert_equal 1, anna_count, 'Anna should appear only once in accounts'

      # Anna should be first (fee payer)
      assert_equal anna_keypair.address, accounts[0]
    end

    it 'handles empty transaction' do
      composer.set_fee_payer(payer_keypair)

      tx = composer.compose_transaction

      assert_instance_of Solace::Transaction, tx

      assert_equal 1, tx.message.accounts.length # Only fee payer
      assert_equal 0, tx.message.instructions.length
      assert_equal payer_keypair.address, tx.message.accounts[0]
    end
  end
end
</file>

<file path="test/usecases/decode_legacy_transaction.rb">
# encoding: ASCII-8BIT
# frozen_string_literal: true

require 'base64'
require 'rbnacl'
require 'base58'
require 'stringio'

require 'test_helper'

# =============================
# 🧩 Legacy Transaction
# =============================
#
# Base64 encoded legacy transaction
#
# rubocop:disable Layout/LineLength
serialized_transaction = 'AcaMpLmLt94VN+8I6G5Gl4fkr8yAawMrfDLgHzllHPuJh9UrMwPGFg8f1+XIPCJ++1gQhUm2iqykguCCW8yLXAEBAAMFrBYKcNpllQ32WLoMCd2PaL1ByibWi05UEFONRtCO9tN/rqFhq+q8I5Y2Z+0JFrZ3yFicOGyV+ehkL4SjrHfiJQan1RcZLwqvxvJl4/t3zHragsUp0L47E24tAFUgAAAABqfVFxjHdMkoVmOYaR1etoteuKObS21cc1VbIQAAAAAHYUgdNXR0u3xNdiTr072z2DVec9EQQ/wNo1OAAAAAAGCuTeqVWHTH4S+Zvy3yupOkl9cHQQW+HrLw7BH9zvaHAQQEAQIDADUCAAAAAQAAAAAAAAADAAAAAAAAAMKSUZmaRJYqMQtNQ+kLV4M8Ln+LqIHtLf+eM3ERhdG3AA=='
# rubocop:enable Layout/LineLength

# Step 1: Base64 decode
transaction_bytes = Base64.decode64(serialized_transaction)

# Step 2: Create a byte stream
io = StringIO.new(transaction_bytes)

# Step 3: Find the number of signatures
num_signatures, = Solace::Utils::Codecs.decode_compact_u16(io)
puts "Number of signatures: #{num_signatures}"

# Step 4: Extract the signatures
signatures = Array.new(num_signatures).map { io.read(64) }
puts "Signatures: #{signatures}"

# Step 5: Extract the message header
message_header = io.read(3).bytes
puts 'Message header:'
puts "  numRequiredSignatures: #{message_header[0]}"
puts "  numReadonlySignedAccounts: #{message_header[1]}"
puts "  numReadonlyUnsignedAccounts: #{message_header[2]}"

# Step 6: Extract the number of account keys
num_accounts, = Solace::Utils::Codecs.decode_compact_u16(io)
puts "Number of account keys: #{num_accounts}"

# Step 7: Extract the account keys
accounts = Array.new(num_accounts).map { io.read(32) }
puts "Account keys: #{accounts}"

# Step 8: Extract the recent blockhash
recent_blockhash = Solace::Utils::Codecs.bytes_to_base58(io.read(32).bytes)
puts "Recent blockhash: #{recent_blockhash}"

# Step 9: Extract the number of instructions
num_instructions, = Solace::Utils::Codecs.decode_compact_u16(io)
puts "Number of instructions: #{num_instructions}"

# Step 10: Extract the instructions
instructions = Array.new(num_instructions).map do
  # 10.1: Extract instruction index
  program_instruction_index = io.read(1).ord
  puts "Program instruction index: #{program_instruction_index}"

  # 10.2: Extract number of accounts
  num_accounts_in_instruction, = Solace::Utils::Codecs.decode_compact_u16(io)
  puts "Number of accounts: #{num_accounts_in_instruction}"

  # 10.3: Extract accounts
  accounts_in_instruction = Array.new(num_accounts_in_instruction).map { io.read(1).ord }
  puts "Accounts: #{accounts_in_instruction}"

  # 10.4: Extract instruction data
  instruction_data_length, = Solace::Utils::Codecs.decode_compact_u16(io)
  puts "Instruction data length: #{instruction_data_length}"

  # 10.5: Extract instruction data
  instruction_data = io.read(instruction_data_length).unpack('C*')
  puts "Instruction data: #{instruction_data}"

  # 10.6: Return instruction
  [
    program_instruction_index,
    num_accounts_in_instruction,
    accounts_in_instruction,
    instruction_data_length,
    instruction_data
  ]
end
puts "Instructions: #{instructions}"

# 11: Confirm end of message
puts "End of message: #{io.eof?}"
</file>

<file path="test/usecases/decode_versioned_transaction.rb">
# encoding: ASCII-8BIT
# frozen_string_literal: true

require 'base64'
require 'rbnacl'
require 'base58'
require 'stringio'

require 'test_helper'

# =============================
# 🧩 Versioned Transaction
# =============================
#
# Base64 encoded versioned transaction
#
# rubocop:disable Layout/LineLength
serialized_transaction = 'Acgu9eEm+Vemca/5lLQJbSJYa0YvkB5bGYafvo4thl6lHNYsSAG7sVh4KAX+k2zPl1gf4zd0Yd9Ds+UVOkIhvwWAAQAEDpkYZngZ374Y0pb6toNS8GHchmk84eLPpT4FJYf5crqomSd1qmAcQwzxZ+k/CeilJsmeji0PQ1cYjpPgihQaOIWIBErEGNasI3hrll4pKZsGHXknGG0+wErI4I5gt02GfJYlqLPaiX4sQV4FMW9kLNv5yW7ehfQRK8XbAqgyNWMlNf7CHxePVFUrXDi1BMb/4ybhol6hmYY5qaC5PldZqTEtApC6Uq9mdQdfYV0bL+7LTUAhN/sLOh2FVZeB3rqseUgWJ/Wlr2SJc6B3X4zsauwJo1l30cYqGje+BVlW8rQ+2mxPsy/Mq5zYLYsZPpxwGo2Mf6HYD38wsqhDpTRfMvb5Cbin+fF73r0gMfSNlfSaAnV+fOpSFHPQN5Yq0KXSELfiD4hBX0flO2syRT6ZYt+fhAzZmL93ET+6qG9NydzRAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBkZv5SEXMv/srbpyw5vnvIzlu8X3EmssQ5s6QAAAAMKC3ZljbddWFnVt++HEh8V+9bue8NoWVHq2eCijyFuLBHnVLe2/a8Xs0J2EU0o0rqWXUEOzb9ArJGULtYRDWVwqyfBc4wPKEDwZ+J83/G1LSd0aTRUzQ+x3nDrAPv64oQQLAAkDAQAAAAAAAAALAAUCY2sOAA05IwAgMS8eLSwdHAggAAggADAKIzIuIiMAEB8OCA8BAQEkIiMAGQIaHxsHBwcrIiMABAIJIAUDBgYMLOUXy5d6460qAAQAAAACFwACEQACEQACEQEfdAAAAAAAAB90AAAAAAAAAAAADRkjAB8mIyclAB8TEiEUESgjKikAIRgXHxYVJOUXy5d6460qAAIAAAACAwIDRzkeAAAAAABHOR4AAAAAAAAAAAZeksiuGUD29Evnx5+b5Awe13wncsSmQU2U1qFnaqfiWANrbJoDbQRpB8dTfmoXCYp/6NAuhjfAkYGFdrwum0jfX4IP+UDTmQwExMbFwwPKyMc9eI6loMOfhEUBficrajwPaSQFTUllI+ZuBSUzy0HtbARQT05NA0lMS9LDB68Y9BoPcKBD37erv38IqCugyHrQuvRdzSVNl2UNA9nd4AHhO9l9gy3odcj1w3FZTmZWYdQ2gP9C6xGhBBeyH+n2swMDW1pXB15YYVZfXGMpc7pKAgpBMfko96SFVmoW5yI6moN3eGQnlJmiZwZQLAOgkUoA'
# rubocop:enable Layout/LineLength

# Step 1: Base64 decode
transaction_bytes = Base64.decode64(serialized_transaction)

# Step 2: Create a byte stream
io = StringIO.new(transaction_bytes)

# Step 3: Find the number of signatures
num_signatures, = Solace::Utils::Codecs.decode_compact_u16(io)
puts "Number of signatures: #{num_signatures}"

# Step 4: Extract the signatures
signatures = []
num_signatures.times { signatures << io.read(64) }
puts "Signatures: #{signatures}"

# Step 5: Check version prefix
version_prefix = io.read(1).unpack1('C')
# io.seek(-1, IO::SEEK_CUR)

puts "Version prefix: #{version_prefix & 0x7F}" # Should be 0

# Step 6: Extract the message header
message_header = io.read(3).bytes
puts 'Message header:'
puts "  numRequiredSignatures: #{message_header[0]}"
puts "  numReadonlySignedAccounts: #{message_header[1]}"
puts "  numReadonlyUnsignedAccounts: #{message_header[2]}"

# Step 7: Extract the number of account keys
num_accounts, = Solace::Utils::Codecs.decode_compact_u16(io)
puts "Number of account keys: #{num_accounts}"

# Step 8: Extract the account keys
accounts = []
num_accounts.times { accounts << io.read(32) }
puts "Account keys: #{accounts}"

# Step 9: Extract the recent blockhash
recent_blockhash = Solace::Utils::Codecs.bytes_to_base58(io.read(32).bytes)
puts "Recent blockhash: #{recent_blockhash}"

# Step 10: Extract the number of instructions
num_instructions, = Solace::Utils::Codecs.decode_compact_u16(io)
puts "Number of instructions: #{num_instructions}"

# Step 11: Extract the instructions
instructions = Array.new(num_instructions).map do
  # 11.1: Extract instruction index
  program_instruction_index = io.read(1).ord
  puts "Program instruction index: #{program_instruction_index}"

  # 11.2: Extract number of accounts
  num_accounts_in_instruction, = Solace::Utils::Codecs.decode_compact_u16(io)
  puts "Number of accounts: #{num_accounts_in_instruction}"

  # 11.3: Extract accounts
  accounts_in_instruction = []
  num_accounts_in_instruction.times { accounts_in_instruction << io.read(1).ord }
  puts "Accounts: #{accounts_in_instruction}"

  # 11.4: Extract instruction data
  instruction_data_length, = Solace::Utils::Codecs.decode_compact_u16(io)
  puts "Instruction data length: #{instruction_data_length}"

  # 11.5: Extract instruction data
  instruction_data = io.read(instruction_data_length).unpack('C*')
  puts "Instruction data: #{instruction_data}"

  # 11.6: Return instruction
  [
    program_instruction_index,
    num_accounts_in_instruction,
    accounts_in_instruction,
    instruction_data_length,
    instruction_data
  ]
end
puts "Instructions: #{instructions}"

# Step 12: Extract address table lookup
num_addresses, = Solace::Utils::Codecs.decode_compact_u16(io)
puts "Number of addresses: #{num_addresses}"

addresses = Array.new(num_addresses).map do
  account_key = Solace::Utils::Codecs.bytes_to_base58 io.read(32).bytes

  num_writable, = Solace::Utils::Codecs.decode_compact_u16(io)
  writable_indexes = io.read(num_writable).unpack('C*')

  num_readonly, = Solace::Utils::Codecs.decode_compact_u16(io)
  readonly_indexes = io.read(num_readonly).unpack('C*')

  [account_key, writable_indexes, readonly_indexes]
end
puts "Addresses: #{addresses}"

# Step 13: Confirm end of message
unless io.eof?
  remaining = io.read
  puts "WARNING: Not at end of message! Remaining bytes: #{remaining.bytes.inspect}"
end
</file>

<file path="test/usecases/sponsored_token_transfer_with_fee.rb">
# frozen_string_literal: true

require 'test_helper'

# 1. Setup
puts '--- Step 1: Setup ---'

# The payer is the account that will pay for the transaction fees and rent.
# It's loaded from fixtures in test_helper.rb
payer = Fixtures.load_keypair('payer')
puts "✅ Payer Account: #{payer.address}"

# The mint is the account that holds information about the token, such as its supply and decimals.
mint = Fixtures.load_keypair('mint')
puts "✅ Mint Account: #{mint.address}"

# The connection to the Solana cluster (devnet by default).
# It's loaded from test_helper.rb
conn = Solace::Connection.new
puts "✅ Connected to cluster: #{conn.rpc_url}"

ata_program = Solace::Programs::AssociatedTokenAccount.new(connection: conn)

# Source and destination account owners and their associated token accounts for the loaded mint.
source_owner = Fixtures.load_keypair('bob')
destination_owner = Fixtures.load_keypair('anna')
fee_collector = Fixtures.load_keypair('fee-collector')

# Get or create associated token accounts
source_ata, = ata_program.get_or_create_address(
  owner: source_owner,
  mint: mint.address,
  payer: payer
)

destination_ata, = ata_program.get_or_create_address(
  owner: destination_owner,
  mint: mint.address,
  payer: payer
)

fee_collector_ata, = ata_program.get_or_create_address(
  owner: fee_collector,
  mint: mint.address,
  payer: payer
)

# Get token account balances
source_ata_start_balance = conn.get_token_account_balance(source_ata)
destination_ata_start_balance = conn.get_token_account_balance(destination_ata)
fee_collector_ata_start_balance = conn.get_token_account_balance(fee_collector_ata)

# 2. Build Instructions
puts '--- Step 2: Building Instructions ---'

# Amount to transfer
transfer_amount = 100_000_000

# Fee collected by the payer
fee_amount = transfer_amount * 0.01

# Accounts
accounts = [
  payer.address,
  source_owner.address,
  source_ata,
  destination_ata,
  fee_collector_ata,
  Solace::Constants::TOKEN_PROGRAM_ID
]

# Instruction for transferring tokens
transfer_ix = Solace::Instructions::SplToken::TransferInstruction.build(
  amount: transfer_amount,
  owner_index: 1,
  source_index: 2,
  destination_index: 3,
  program_index: 5
)

# Instruction for collecting fee
fee_ix = Solace::Instructions::SplToken::TransferInstruction.build(
  amount: fee_amount,
  owner_index: 1,
  source_index: 2,
  destination_index: 4,
  program_index: 5
)

# 3. Prepare the transaction
puts '--- Step 3: Preparing Transaction ---'

# Message
message = Solace::Message.new(
  header: [2, 0, 1],
  accounts: accounts,
  instructions: [transfer_ix, fee_ix],
  recent_blockhash: conn.get_latest_blockhash
)

# Transaction
tx = Solace::Transaction.new(message: message)

# 4. Sign and send the transaction
puts '--- Step 4: Signing and Sending Transaction ---'
tx.sign(payer, source_owner)

response = conn.send_transaction(tx.serialize)
conn.wait_for_confirmed_signature { response['result'] }

# 5. Print final balances
puts '--- Step 5: Printing Final Balances ---'

source_ata_end_balance = conn.get_token_account_balance(source_ata)
destination_ata_end_balance = conn.get_token_account_balance(destination_ata)
fee_collector_ata_end_balance = conn.get_token_account_balance(fee_collector_ata)

puts "
✅ Fee Collector's account:
- Primary: #{fee_collector.address}
- ATA: #{fee_collector_ata}
- Start Token Balance: #{fee_collector_ata_start_balance['uiAmountString']}
- End Token Balance: #{fee_collector_ata_end_balance['uiAmountString']}

✅ Bobs's account:
- Primary: #{source_owner.address}
- ATA: #{source_ata}
- Start Token Balance: #{source_ata_start_balance['uiAmountString']}
- End Token Balance: #{source_ata_end_balance['uiAmountString']}

✅ Annas's account:
- Primary: #{destination_owner.address}
- ATA: #{destination_ata}
- Start Token Balance: #{destination_ata_start_balance['uiAmountString']}
- End Token Balance: #{destination_ata_end_balance['uiAmountString']}
"
</file>

<file path="test/usecases/test_transfer_sdk.rb">
# frozen_string_literal: true

# test_transfer.rb

require 'base58'
require 'test_helper'

bob = JSON.load_file(File.expand_path('../fixtures/bob.json', __dir__))
anna = JSON.load_file(File.expand_path('../fixtures/anna.json', __dir__))

puts bob

# 1. Generate sender and recipient keypairs
sender = Solace::Keypair.from_secret_key(bob.pack('C*'))
recipient = Solace::Keypair.from_secret_key(anna.pack('C*'))

# 2. Connect to local validator
conn = Solace::Connection.new

# 3. Print initial balances
sender_balance = conn.get_balance(sender.address)
recipient_balance = conn.get_balance(recipient.address)

puts "Sender balance: #{sender_balance} lamports"
puts "Recipient balance: #{recipient_balance} lamports"

# 4. Build instruction
instruction = Solace::Instructions::SystemProgram::TransferInstruction.build(
  to_index: 1,
  from_index: 0,
  program_index: 2,
  lamports: 10_000_000 # 0.01 SOL
)

# 5. Build message
message = Solace::Message.new(
  header: [
    1, # num_required_signatures
    0, # num_readonly_signed
    1  # num_readonly_unsigned
  ],
  accounts: [
    sender.address,
    recipient.address,
    Solace::Constants::SYSTEM_PROGRAM_ID
  ],
  recent_blockhash: conn.get_latest_blockhash,
  instructions: [instruction]
)

# 6. Build transaction
transaction = Solace::Transaction.new(message: message)

# 7. Sign transaction
transaction.sign(sender)

# 8. Send transaction
result = conn.send_transaction(transaction.serialize)

puts "Transaction sent: #{result}"

# 9. Print final balances
puts "Sender balance after: #{`solana balance #{sender.address}`}"
puts "Recipient balance after: #{`solana balance #{recipient.address}`}"
</file>

<file path="test/bootstrap.rb">
# frozen_string_literal: true

# test/bootstrap.rb

# Bootstraps the test environment with a Solana test validator and some pre-funded accounts.

require 'minitest/mock'
require 'minitest/autorun'
require 'minitest/hooks/default'

require 'solace'

require_relative 'support/fixtures'
require_relative 'support/factory_bot'
require_relative 'support/solana_test_validator'

# Make sure keypairs are loaded
bob = Fixtures.load_keypair('bob')
anna = Fixtures.load_keypair('anna')
payer = Fixtures.load_keypair('payer')
mint = Fixtures.load_keypair('mint')
mint_authority = Fixtures.load_keypair('mint-authority')
fee_collector = Fixtures.load_keypair('fee-collector')

# Make sure connection is loaded
connection = Solace::Connection.new(commitment: 'finalized')
spl_token_program = Solace::Programs::SplToken.new(connection: connection)
ata_program = Solace::Programs::AssociatedTokenAccount.new(connection: connection)

# Amounts to airdrop
TOKENS_AIRDROP = 10_000_000
LAMPORTS_AIRDROP = 10_000_000_000

puts "Bootstrapping...\n\n"
setup_payer = Solace::Keypair.generate
result = connection.request_airdrop(setup_payer.address, LAMPORTS_AIRDROP)
connection.wait_for_confirmed_signature('finalized') { result['result'] }

# Create mint
if connection.get_account_info(mint.address).nil?
  puts '============= Creating Mint ==============='
  puts "⤷ Mint Address: #{mint.address}"
  puts "⤷ Mint Authority: #{mint_authority.address}"

  response = spl_token_program.create_mint(
    payer: setup_payer,
    decimals: 6,
    freeze_authority: nil,
    mint_keypair: mint,
    mint_authority: mint_authority
  )
  connection.wait_for_confirmed_signature('finalized') { response['result'] }
end

[
  {
    name: 'payer',
    keypair: payer
  },
  {
    name: 'bob',
    keypair: bob
  },
  {
    name: 'anna',
    keypair: anna
  },
  {
    name: 'mint-authority',
    keypair: mint_authority
  },
  {
    name: 'fee-collector',
    keypair: fee_collector
  }
].each do |account|
  # Extract name and keypair from account hash
  name, keypair = account.values_at(:name, :keypair)

  puts "\n\n========== Bootstrapping #{name} =========="

  puts "⤷ Airdropping #{LAMPORTS_AIRDROP / 1_000_000_000} SOL..."
  result = connection.request_airdrop(keypair.address, LAMPORTS_AIRDROP)

  puts "⤷ Signature: #{result['result']}"
  connection.wait_for_confirmed_signature('finalized') { result['result'] }

  puts "⤷ Airdropping #{TOKENS_AIRDROP / 1_000_000} tokens..."
  bob_ata = ata_program.get_or_create_address(
    payer: setup_payer,
    owner: keypair,
    mint: mint,
    commitment: 'finalized'
  )

  result = spl_token_program.mint_to(
    payer: setup_payer,
    mint: mint,
    destination: bob_ata,
    amount: TOKENS_AIRDROP,
    mint_authority: mint_authority
  )

  puts "⤷ Signature: #{result['result']}"
  connection.wait_for_confirmed_signature('finalized') { result['result'] }
end
</file>

<file path="console.rb">
# frozen_string_literal: true

require 'irb'

# Autoload all Ruby files in utils and other directories as needed
require_relative 'lib/solace'

require 'minitest/autorun'
require 'minitest/hooks/default'

require_relative 'test/support/fixtures'
require_relative 'test/support/factory_bot'
require_relative 'test/support/solana_test_validator'

# Start IRB
IRB.start
</file>

<file path="lib/solace/composers/base.rb">
# frozen_string_literal: true

module Solace
  module Composers
    # A Base class for all composers
    #
    # @since 0.0.3
    class Base
      # @!attribute  params
      #   The params for the composer
      #
      # @return [Hash] The parameters passed to the composer
      attr_reader :params

      # @!attribute  account_context
      #   The account_context for the composer
      #
      # @return [Utils::AccountContext] The AccountContext instance for the composer
      attr_reader :account_context

      # Initialize the composer
      #
      # @param params [Hash] Parameters to pass to the composer constructor
      def initialize(params)
        @params = params
        @account_context = Utils::AccountContext.new
        setup_accounts
      end

      # Setup accounts required for this instruction
      #
      # @return [void]
      def setup_accounts
        raise NotImplementedError, 'Subclasses must implement setup_accounts method'
      end

      # Build instruction with resolved account indices
      #
      # @return [void]
      def build_instruction(indices)
        raise NotImplementedError, 'Subclasses must implement build_instruction method'
      end
    end
  end
end
</file>

<file path="lib/solace/composers/spl_token_program_transfer_checked_composer.rb">
# frozen_string_literal: true

module Solace
  module Composers
    # Composer for creating a SPL Token Program `TransferChecked` instruction.
    #
    # This composer resolves and orders the required accounts for a `TransferChecked` instruction,
    # sets up their access permissions, and delegates construction to the appropriate
    # instruction builder (`Instructions::SplToken::TransferCheckedInstruction`).
    #
    # It is used for transferring SPL tokens with decimal precision and validation checks.
    #
    # Required accounts:
    # - **From**: source token account (writable, non-signer)
    # - **To**: destination token account (writable, non-signer)
    # - **Mint**: mint address (readonly, non-signer)
    # - **Authority**: token owner (writable, signer)
    # - **Program**: SPL Token program (readonly, non-signer)
    #
    # @example Compose and build a transfer_checked instruction
    #   composer = SplTokenProgramTransferCheckedComposer.new(
    #     from: from_address,
    #     to: to_address,
    #     mint: mint_address,
    #     authority: authority_pubkey,
    #     amount: 1_000_000,
    #     decimals: 6
    #   )
    #
    # @see Instructions::SplToken::TransferCheckedInstruction
    # @since 0.0.3
    class SplTokenProgramTransferCheckedComposer < Base
      # Extracts the to address from the params
      #
      # @return [String] The to address
      def to
        params[:to].to_s
      end

      # Extracts the from address from the params
      #
      # @return [String] The from address
      def from
        params[:from].to_s
      end

      # Extracts the authority address from the params
      #
      # The authority is the owner of the token account
      #
      # @return [String] The authority address
      def authority
        params[:authority].to_s
      end

      # Extracts the mint address from the params
      #
      # @return [String] The mint address
      def mint
        params[:mint].to_s
      end

      # Returns the spl token program id
      #
      # @return [String] The spl token program id
      def spl_token_program
        Constants::TOKEN_PROGRAM_ID.to_s
      end

      # Returns the lamports to transfer
      #
      # @return [Integer] The lamports to transfer
      def amount
        params[:amount]
      end

      # Returns the decimals for the mint of the token
      #
      # @return [Integer] The decimals for the mint
      def decimals
        params[:decimals]
      end

      # Setup accounts required for transfer instruction
      # Called automatically during initialization
      #
      # @return [void]
      def setup_accounts
        account_context.add_writable_signer(authority)
        account_context.add_writable_nonsigner(to)
        account_context.add_writable_nonsigner(from)
        account_context.add_readonly_nonsigner(mint)
        account_context.add_readonly_nonsigner(spl_token_program)
      end

      # Build instruction with resolved account indices
      #
      # @param account_context [Utils::AccountContext] The account context
      # @return [Solace::Instruction]
      def build_instruction(account_context)
        Instructions::SplToken::TransferCheckedInstruction.build(
          amount: amount,
          decimals: decimals,
          to_index: account_context.index_of(to),
          from_index: account_context.index_of(from),
          mint_index: account_context.index_of(mint),
          authority_index: account_context.index_of(authority),
          program_index: account_context.index_of(spl_token_program)
        )
      end
    end
  end
end
</file>

<file path="lib/solace/concerns/binary_serializable.rb">
# frozen_string_literal: true

module Solace
  module Concerns
    # Adds binary serialization support to a class
    #
    # Transactions, Messages, Instructions, and AddressLookupTables are all binary serializable.
    # These classes use this concern to add binary serialization support.
    #
    # @see Solace::Transaction
    # @see Solace::Message
    # @see Solace::Instruction
    # @see Solace::AddressLookupTable
    # @since 0.0.1
    module BinarySerializable
      # Include the module
      #
      # @param base [Class] The base class to include the module into
      def self.included(base)
        base.extend ClassMethods
      end

      # Returns the binary decoded from the serialized string
      #
      # Expects the class to have a `serialize` method that returns a base64 string.
      #
      # @return [String] The binary decoded from the serialized string
      def to_binary
        Base64.decode64(serialize)
      end

      # Returns a StringIO stream of the binary data
      #
      # @return [IO] The StringIO stream of the binary data
      def to_io
        StringIO.new(to_binary)
      end

      # Returns the bytes of the binary data as an array of integers
      #
      # @return [Array] The bytes of the binary data as an array of integers
      def to_bytes
        to_binary.bytes
      end

      # Serializes the record to a binary format
      #
      # @return [String] The serialized record (binary)
      def serialize
        self.class::SERIALIZER.new(self).call
      rescue NameError => e
        raise "SERIALIZER must be defined: #{e.message}"
      end

      # Class methods for binary serializable
      module ClassMethods
        # Parse record from bytestream
        #
        # @param stream [IO, StringIO] The input to read bytes from.
        # @return [Solace::Instruction] Parsed instruction instance
        def deserialize(stream)
          self::DESERIALIZER.new(stream).call
        rescue NameError => e
          raise "DESERIALIZER must be defined: #{e.message}"
        end
      end
    end
  end
end
</file>

<file path="lib/solace/instructions/associated_token_account/create_associated_token_account_instruction.rb">
# frozen_string_literal: true

module Solace
  module Instructions
    module AssociatedTokenAccount
      # Instruction for creating an Associated Token Account.
      #
      # This is a special "all-in-one" instruction that creates and initializes the account. It
      # is used to create an Associated Token Account (ATA) for a given mint and owner.
      #
      # @example Build a CreateAssociatedTokenAccount instruction
      #   instruction = Solace::Instructions::AssociatedTokenAccount::CreateAssociatedTokenAccountInstruction.build(
      #     funder_index: 0,
      #     associated_token_account_index: 1,
      #     owner_index: 2,
      #     mint_index: 3,
      #     system_program_index: 4,
      #     token_program_index: 5,
      #     program_index: 6
      #   )
      #
      # @since 0.0.2
      class CreateAssociatedTokenAccountInstruction
        # !@const INSTRUCTION_INDEX
        #   Instruction index for CreateAssociatedTokenAccount
        #
        # @return [Array<Integer>]
        INSTRUCTION_INDEX = [0].freeze

        # Builds a CreateAssociatedTokenAccount instruction.
        #
        # The on-chain program requires accounts in a specific order:
        # 1. [writable, signer] Funder: The account paying for the rent.
        # 2. [writable] ATA: The new Associated Token Account to be created.
        # 3. [readonly] Owner: The wallet that will own the new ATA.
        # 4. [readonly] Mint: The token mint for the new ATA.
        # 5. [readonly] System Program: Required to create the account.
        # 6. [readonly] SPL Token Program: Required to initialize the account.
        #
        # @param funder_index [Integer] Index of the funding account (payer).
        # @param associated_token_account_index [Integer] Index of the Associated Token Account to be created.
        # @param owner_index [Integer] Index of the wallet that will own the new ATA.
        # @param mint_index [Integer] Index of the token mint.
        # @param system_program_index [Integer] Index of the System Program.
        # @param token_program_index [Integer] Index of the SPL Token Program.
        # @param program_index [Integer] Index of the Associated Token Program itself.
        # @return [Solace::Instruction]
        def self.build(
          funder_index:,
          associated_token_account_index:,
          owner_index:,
          mint_index:,
          system_program_index:,
          token_program_index:,
          program_index:
        )
          Solace::Instruction.new.tap do |ix|
            ix.program_index = program_index
            ix.accounts = [
              funder_index,
              associated_token_account_index,
              owner_index,
              mint_index,
              system_program_index,
              token_program_index
            ]
            ix.data = data
          end
        end

        # Data for a CreateAssociatedTokenAccount instruction
        #
        # The BufferLayout is:
        #   - [Instruction Index (1 byte)]
        #
        # @return [Array] 1-byte instruction index
        def self.data
          INSTRUCTION_INDEX
        end
      end
    end
  end
end
</file>

<file path="lib/solace/instructions/spl_token/initialize_account_instruction.rb">
# frozen_string_literal: true

# lib/solace/instructions/spl_token/initialize_account_instruction.rb

module Solace
  module Instructions
    module SplToken
      # Instruction for initializing a new token account.
      #
      # This instruction is used to initialize a new token account for a given mint and owner. It
      # is used in conjunction with the CreateAccount instruction to create and initialize a new
      # token account. Note that the AssociatedTokenAccount::CreateAssociatedTokenAccountInstruction
      # is a special "all-in-one" instruction that creates and initializes the account in a single
      # instruction.
      #
      # @example Build an InitializeAccount instruction
      #   instruction = Solace::Instructions::SplToken::InitializeAccountInstruction.build(
      #     account_index: 0,
      #     mint_index: 1,
      #     owner_index: 2,
      #     rent_sysvar_index: 3,
      #     program_index: 4
      #   )
      #
      # @see Solace::Instructions::AssociatedTokenAccount::CreateAssociatedTokenAccountInstruction
      # @see Solace::Instructions::SystemProgram::CreateAccountInstruction
      # @since 0.0.2
      class InitializeAccountInstruction
        # @!attribute [Array<Integer>] INSTRUCTION_INDEX
        #   Instruction index for SPL Token Program's InitializeAccount instruction.
        INSTRUCTION_INDEX = [1].freeze

        # Builds a SPLToken::InitializeAccount instruction.
        #
        # @param account_index [Integer] Index of the new token account in the transaction's accounts.
        # @param mint_index [Integer] Index of the mint account in the transaction's accounts.
        # @param owner_index [Integer] Index of the owner of the new account in the transaction's accounts.
        # @param rent_sysvar_index [Integer] Index of the Rent Sysvar in the transaction's accounts.
        # @param program_index [Integer] Index of the SPL Token program in the transaction's accounts.
        # @return [Solace::Instruction]
        def self.build(
          account_index:,
          mint_index:,
          owner_index:,
          rent_sysvar_index:,
          program_index:
        )
          Solace::Instruction.new.tap do |ix|
            ix.program_index = program_index
            ix.accounts = [account_index, mint_index, owner_index, rent_sysvar_index]
            ix.data = data
          end
        end

        # Builds the data for a SPLToken::InitializeAccount instruction.
        #
        # The BufferLayout is:
        #   - [Instruction Index (1 byte)]
        #
        # @return [Array] 1-byte instruction index
        def self.data
          INSTRUCTION_INDEX
        end
      end
    end
  end
end
</file>

<file path="lib/solace/instructions/spl_token/initialize_mint_instruction.rb">
# frozen_string_literal: true

module Solace
  module Instructions
    module SplToken
      # Instruction for initializing a new mint.
      #
      # This instruction is used to initialize a new mint for a given token. It is used in conjunction with the SystemProgram::CreateAccount
      # instruction to create and initialize a new mint account.
      #
      # @example Build an InitializeMint instruction
      #   instruction = Solace::Instructions::SplToken::InitializeMintInstruction.build(
      #     decimals: 6,
      #     mint_authority: mint_authority.address,
      #     freeze_authority: freeze_authority.address,
      #     rent_sysvar_index: 2,
      #     mint_account_index: 1,
      #     program_index: 3
      #   )
      #
      # @see Solace::Instructions::SystemProgram::CreateAccountInstruction
      # @since 0.0.2
      class InitializeMintInstruction
        # Instruction index for Initialize Mint
        INSTRUCTION_INDEX = [0].freeze

        # Builds a Solace::Instruction for initializing an SPL Token Program mint
        #
        # The BufferLayout is:
        #   - [Instruction Index (1 byte)]
        #   - [Decimals (1 byte)]
        #   - [Mint authority (32 bytes)]
        #   - [Freeze authority option (1 byte)]
        #   - [Freeze authority (32 bytes)]
        #
        # @param decimals [Integer] Number of decimals for the token
        # @param mint_authority [String] Public key of the mint authority
        # @param freeze_authority [String, nil] Public key of the freeze authority
        # @param rent_sysvar_index [Integer] Index of the rent sysvar in the transaction's accounts
        # @param mint_account_index [Integer] Index of the mint account in the transaction's accounts
        # @param program_index [Integer] Index of the SPL Token Program in the transaction's accounts (default: 3)
        # @return [Solace::Instruction]
        def self.build(
          decimals:,
          mint_authority:,
          rent_sysvar_index:,
          mint_account_index:,
          freeze_authority: nil,
          program_index: 2
        )
          Solace::Instruction.new.tap do |ix|
            ix.program_index = program_index
            ix.accounts = [mint_account_index, rent_sysvar_index]
            ix.data = data(decimals, mint_authority, freeze_authority)
          end
        end

        # Instruction data for an initialize mint instruction
        #
        # The BufferLayout is:
        #   - [Instruction Index (1 byte)]
        #   - [Decimals (1 byte)]
        #   - [Mint authority (32 bytes)]
        #   - [Freeze authority option (33 byte)]
        #
        # @param decimals [Integer] Number of decimals for the token
        # @param mint_authority [String] Public key of the mint authority
        # @param freeze_authority [String, nil] Public key of the freeze authority
        # @return [Array<u8>] The instruction data
        def self.data(decimals, mint_authority, freeze_authority)
          INSTRUCTION_INDEX +
            [decimals] +
            Solace::Utils::Codecs.base58_to_bytes(mint_authority) +
            (
              if freeze_authority
                [1] + Solace::Utils::Codecs.base58_to_bytes(freeze_authority)
              else
                [0]
              end
            )
        end
      end
    end
  end
end
</file>

<file path="lib/solace/serializers/address_lookup_table_deserializer.rb">
# frozen_string_literal: true

module Solace
  module Serializers
    # Deserializes a Solana address lookup table from a binary format.
    #
    # @since 0.0.2
    class AddressLookupTableDeserializer < Solace::Serializers::BaseDeserializer
      # @!attribute record_class
      #   The class of the record being deserialized
      #
      # @return [Class] The class of the record
      self.record_class = Solace::AddressLookupTable

      # @!attribute steps
      #   An ordered list of methods to deserialize the address lookup table
      #
      # @return [Array] The steps to deserialize the address lookup table
      self.steps = %i[
        next_extract_account
        next_extract_writable_indexes
        next_extract_readonly_indexes
      ]

      # Extract the account key from the transaction
      #
      # The BufferLayout is:
      #   - [Account key (32 bytes)]
      #
      # @return [String] The account key
      def next_extract_account
        record.account = Codecs.bytes_to_base58 io.read(32).bytes
      end

      # Extract the writable indexes from the transaction
      #
      # The BufferLayout is:
      #   - [Number of writable indexes (compact u16)]
      #   - [Writable indexes (variable length u8)]
      #
      # @return [Array<Integer>] The writable indexes
      def next_extract_writable_indexes
        length, = Codecs.decode_compact_u16(io)
        record.writable_indexes = io.read(length).unpack('C*')
      end

      # Extract the readonly indexes from the transaction
      #
      # The BufferLayout is:
      #   - [Number of readonly indexes (compact u16)]
      #   - [Readonly indexes (variable length u8)]
      #
      # @return [Array<Integer>] The readonly indexes
      def next_extract_readonly_indexes
        length, = Codecs.decode_compact_u16(io)
        record.readonly_indexes = io.read(length).unpack('C*')
      end
    end
  end
end
</file>

<file path="lib/solace/serializers/address_lookup_table_serializer.rb">
# frozen_string_literal: true

module Solace
  module Serializers
    # Serializes a Solana address lookup table to a binary format.
    #
    # @since 0.0.2
    class AddressLookupTableSerializer < Solace::Serializers::BaseSerializer
      # @!attribute steps
      #   An ordered list of methods to serialize the address lookup table
      #
      # @return [Array] The steps to serialize the address lookup table
      self.steps = %i[
        encode_account
        encode_writable_indexes
        encode_readonly_indexes
      ]

      # Encodes the account of the address lookup table
      #
      # The BufferLayout is:
      #   - [Account key (32 bytes)]
      #
      # @return [Array<Integer>] The bytes of the encoded account
      def encode_account
        Codecs.base58_to_bytes(record.account)
      end

      # Encodes the writable indexes of the address lookup table
      #
      # The BufferLayout is:
      #   - [Number of writable indexes (compact u16)]
      #   - [Writable indexes (variable length u8)]
      #
      # @return [Array<Integer>] The bytes of the encoded writable indexes
      def encode_writable_indexes
        Codecs.encode_compact_u16(record.writable_indexes.size).bytes +
          record.writable_indexes
      end

      # Encodes the readonly indexes of the address lookup table
      #
      # The BufferLayout is:
      #   - [Number of readonly indexes (compact u16)]
      #   - [Readonly indexes (variable length u8)]
      #
      # @return [Array<Integer>] The bytes of the encoded readonly indexes
      def encode_readonly_indexes
        Codecs.encode_compact_u16(record.readonly_indexes.size).bytes +
          record.readonly_indexes
      end
    end
  end
end
</file>

<file path="lib/solace/serializers/base_deserializer.rb">
# frozen_string_literal: true

module Solace
  # Serializers module
  module Serializers
    # Autoload deserializers
    autoload :TransactionDeserializer, 'solace/serializers/transaction_deserializer'
    autoload :MessageDeserializer, 'solace/serializers/message_deserializer'
    autoload :InstructionDeserializer, 'solace/serializers/instruction_deserializer'
    autoload :AddressLookupTableDeserializer, 'solace/serializers/address_lookup_table_deserializer'

    # The base deserializer class
    #
    # This class provides a consistent interface for deserializing records.
    #
    # @abstract
    # @since 0.0.1
    class BaseDeserializer
      include Solace::Utils

      # @!attribute io
      #   The input to read bytes from.
      #
      # @return [IO, StringIO] The input to read bytes from.
      attr_reader :io

      # @!attribute record
      #   The record instance being deserialized.
      #
      # @return [Record] The deserialized record.
      attr_reader :record

      # Initialize a new deserializer
      #
      # @param io [IO, StringIO] The input to read bytes from.
      # @return [BaseDeserializer] The new deserializer object
      def initialize(io)
        super()
        @io = io
        @record = self.class.record_class.new
      end

      # Deserializes the record
      #
      # @return [Record] The deserialized record
      def call
        self.class.steps.each { send(_1) }
        record
      end

      class << self
        # @!attribute steps
        #   An ordered list of methods to deserialize the record
        #
        # @return [Array] The steps to deserialize the record
        attr_accessor :steps

        # @!attribute record_class
        #   The class of the record being deserialized
        #
        # @return [Class] The class of the record
        attr_accessor :record_class
      end
    end
  end
end
</file>

<file path="lib/solace/serializers/base_serializer.rb">
# frozen_string_literal: true

module Solace
  # Serializers module
  module Serializers
    # Autoload serializers
    autoload :TransactionSerializer, 'solace/serializers/transaction_serializer'
    autoload :MessageSerializer, 'solace/serializers/message_serializer'
    autoload :InstructionSerializer, 'solace/serializers/instruction_serializer'
    autoload :AddressLookupTableSerializer, 'solace/serializers/address_lookup_table_serializer'

    # The base serializer class
    #
    # This class provides a consistent interface for serializing records.
    #
    # @abstract
    # @since 0.0.1
    class BaseSerializer
      include Solace::Utils

      # @!attribute record
      #   The record instance being serialized.
      #
      # @return [Record] The serialized record.
      attr_reader :record

      # Initialize a new serializer
      #
      # @param record [Record] The record to serialize
      # @return [BaseSerializer] The new serializer object
      def initialize(record)
        super()
        @record = record
      end

      # Serializes the record
      #
      # @return [String] The serialized record (base64)
      def call
        bin = self.class
                  .steps
                  .map { |m| send(m) }
                  .flatten
                  .compact
                  .pack('C*')

        Base64.strict_encode64(bin)
      rescue NameError => e
        raise "STEPS must be defined: #{e.message}"
      end

      class << self
        # @!attribute steps
        #   An ordered list of methods to serialize the record
        #
        # @return [Array] The steps to serialize the record
        attr_accessor :steps
      end
    end
  end
end
</file>

<file path="lib/solace/serializers/instruction_deserializer.rb">
# frozen_string_literal: true

module Solace
  module Serializers
    # Deserializes a binary instruction into a Solace::Instruction object.
    #
    # @since 0.0.1
    class InstructionDeserializer < Solace::Serializers::BaseDeserializer
      # @!attribute  record_class
      #   The class of the record being deserialized
      #
      # @return [Class] The class of the record
      self.record_class = Solace::Instruction

      # @!attribute  steps
      #   An ordered list of methods to deserialize the instruction
      #
      # @return [Array] The steps to deserialize the instruction
      self.steps = %i[
        next_extract_program_index
        next_extract_accounts
        next_extract_data
      ]

      # Extracts the program index from the instruction
      #
      # The BufferLayout is:
      #   - [Program index (1 byte)]
      #
      # @return [Integer] The program index
      def next_extract_program_index
        record.program_index = io.read(1).ord
      end

      # Extracts the accounts from the instruction
      #
      # The BufferLayout is:
      #   - [Number of accounts (compact u16)]
      #   - [Accounts (variable length u8)]
      #
      # @return [Array] The accounts
      def next_extract_accounts
        length, = Codecs.decode_compact_u16(io)
        record.accounts = io.read(length).unpack('C*')
      end

      # Extracts the instruction data from the instruction
      #
      # The BufferLayout is:
      #   - [Number of data bytes (compact u16)]
      #   - [Data bytes (variable length u8)]
      #
      # @return [Array] The instruction data
      def next_extract_data
        length, = Codecs.decode_compact_u16(io)
        record.data = io.read(length).unpack('C*')
      end
    end
  end
end
</file>

<file path="lib/solace/serializers/instruction_serializer.rb">
# frozen_string_literal: true

module Solace
  module Serializers
    # Serializes a Solana instruction to a binary format.
    #
    # @since 0.0.1
    class InstructionSerializer < Solace::Serializers::BaseSerializer
      # @!attribute  steps
      #   An ordered list of methods to serialize the instruction
      #
      # @return [Array] The steps to serialize the instruction
      self.steps = %i[
        encode_program_index
        encode_accounts
        encode_data
      ]

      # Encodes the program index of the instruction
      #
      # The BufferLayout is:
      #   - [Program index (u8)]
      #
      # @return [Integer] The bytes of the encoded program index
      def encode_program_index
        record.program_index
      end

      # Encodes the accounts of the instruction
      #
      # The BufferLayout is:
      #   - [Number of accounts (compact u16)]
      #   - [Accounts (variable length u8)]
      #
      # @return [Array<Integer>] The bytes of the encoded accounts
      def encode_accounts
        Codecs.encode_compact_u16(record.accounts.size).bytes + record.accounts
      end

      # Encodes the data of the instruction
      #
      # The BufferLayout is:
      #   - [Number of data bytes (compact u16)]
      #   - [Data bytes (variable length u8)]
      #
      # @return [Array<Integer>] The bytes of the encoded data
      def encode_data
        Codecs.encode_compact_u16(record.data.size).bytes + record.data
      end
    end
  end
end
</file>

<file path="lib/solace/serializers/message_serializer.rb">
# frozen_string_literal: true

module Solace
  module Serializers
    # Serializes a Solana message to a binary format.
    #
    # @since 0.0.1
    class MessageSerializer < Solace::Serializers::BaseSerializer
      # @!attribute steps
      #   An ordered list of methods to serialize the message
      #
      # @return [Array] The steps to serialize the message
      self.steps = %i[
        encode_version
        encode_message_header
        encode_accounts
        encode_recent_blockhash
        encode_instructions
        encode_address_lookup_table
      ]

      # Encodes the version of the message
      #
      # The BufferLayout is:
      #   - [Version (1 byte)]
      #
      # @return [Array<Integer>] | nil The bytes of the encoded version
      def encode_version
        [0x80 | record.version] if record.versioned?
      end

      # Encodes the message header of the transaction
      #
      # The BufferLayout is:
      #   - [Message header (3 bytes)]
      #
      # @return [Array<Integer>] The bytes of the encoded message header
      def encode_message_header
        record.header
      end

      # Encodes the accounts of the transaction
      #
      # The BufferLayout is:
      #   - [Number of accounts (compact u16)]
      #   - [Accounts (variable length)]
      #
      # @return [Array<Integer>] The bytes of the encoded accounts
      def encode_accounts
        Codecs.encode_compact_u16(record.accounts.size).bytes +
          record.accounts.map { Codecs.base58_to_bytes(_1) }
      end

      # Encodes the recent blockhash of the transaction
      #
      # The BufferLayout is:
      #   - [Recent blockhash (32 bytes)]
      #
      # @return [Array<Integer>] The bytes of the encoded recent blockhash
      def encode_recent_blockhash
        raise 'Failed to serialize message: recent blockhash is nil' if record.recent_blockhash.nil?

        Codecs.base58_to_bytes(record.recent_blockhash)
      end

      # Encodes the instructions of the transaction
      #
      # The BufferLayout is:
      #   - [Number of instructions (compact u16)]
      #   - [Instructions (variable length)]
      #
      # @return [Array<Integer>] The bytes of the encoded instructions
      def encode_instructions
        Codecs.encode_compact_u16(record.instructions.size).bytes +
          record.instructions.map(&:to_bytes)
      end

      # Encodes the address lookup table of the transaction
      #
      # The BufferLayout is:
      #   - [Number of address lookup tables (compact u16)]
      #   - [Address lookup tables (variable length)]
      #
      # @return [Array<Integer>] The bytes of the encoded address lookup table
      def encode_address_lookup_table
        return unless record.versioned?

        Codecs.encode_compact_u16(record.address_lookup_tables.size).bytes +
          record.address_lookup_tables.map(&:to_bytes)
      end
    end
  end
end
</file>

<file path="lib/solace/serializers/transaction_deserializer.rb">
# frozen_string_literal: true

module Solace
  module Serializers
    # Deserializes a binary transaction into a Solace::Transaction object.
    #
    # @since 0.0.1
    class TransactionDeserializer < Solace::Serializers::BaseDeserializer
      # @!attribute record_class
      #   The class of the record being deserialized
      #
      # @return [Class] The class of the record
      self.record_class = Solace::Transaction

      # @!attribute  steps
      #   An ordered list of methods to deserialize the transaction
      #
      # @return [Array] The steps to deserialize the transaction
      self.steps = %i[
        next_extract_signatures
        next_extract_message
      ]

      # Extract signatures from the transaction
      #
      # The BufferLayout is:
      #   - [Number of signatures (compact u16)]
      #   - [Signatures (variable length)]
      #
      # @return [Array] Array of base58 encoded signatures
      def next_extract_signatures
        count, = Codecs.decode_compact_u16(io)
        record.signatures = count.times.map { io.read(64) }
      end

      # Extract the message from the transaction
      #
      # The BufferLayout is:
      #   - [Message (variable length)]
      #
      # @return [Solace::Message] The deserialized message instance
      def next_extract_message
        record.message = Solace::Serializers::MessageDeserializer.new(io).call
      end
    end
  end
end
</file>

<file path="lib/solace/utils/account_context.rb">
# frozen_string_literal: true

module Solace
  module Utils
    # Utility for managing account context for composers
    #
    # This utility is used to manage the accounts in a transaction composer and instructions composer. It
    # provides methods for managing the accounts and their permissions, as well as compiling the accounts
    # into the final format required by the instruction builders. Concerns like deduplication and ordering
    # are handled by this utility.
    #
    # @example Usage
    #   # Create a new account context
    #   context = Solace::Utils::AccountContext.new
    #
    #   # Add accounts
    #   context.add_writable_signer('pubkey1')
    #   context.add_readonly_nonsigner('pubkey2')
    #
    #   # Merge accounts from another context
    #   context = context.merge_from(other_context)
    #
    #   # Set fee payer
    #   context.set_fee_payer('pubkey3')
    #
    #   # Compile the accounts
    #   context.compile
    #
    # @see Solace::TransactionComposer
    # @see Solace::Composers::Base
    # @since 0.0.3
    class AccountContext
      # @!attribute  DEFAULT_ACCOUNT
      #   The default account data
      #
      # @return [Hash] The default account data with lowest level of permissions
      DEFAULT_ACCOUNT = {
        signer: false,
        writable: false,
        fee_payer: false
      }.freeze

      # @!attribute  header
      #   The header for the transaction
      #
      # @return [Array<Integer>] The header for the transaction
      attr_accessor :header

      # @!attribute  accounts
      #   The accounts in the transaction
      #
      # @return [Array<String>] The accounts
      attr_accessor :accounts

      # @!attribute  pubkey_account_map
      #   The map of accounts
      #
      # @return [Hash] The map of accounts
      attr_accessor :pubkey_account_map

      # Initialize the account context
      def initialize
        @header = []
        @accounts = []
        @pubkey_account_map = {}
      end

      # Set the fee payer account
      #
      # @param pubkey [Solace::Keypair, Solace::PublicKey, String] The pubkey of the fee payer account
      def set_fee_payer(pubkey)
        merge_account(pubkey, signer: true, writable: true, fee_payer: true)
      end

      # Add a signer account
      #
      # @param pubkey [Solace::Keypair, Solace::PublicKey, String] The pubkey of the signer account
      def add_writable_signer(pubkey)
        merge_account(pubkey, signer: true, writable: true)
      end

      # Add a writable account
      #
      # @param pubkey [Solace::Keypair, Solace::PublicKey, String] The pubkey of the writable account
      def add_writable_nonsigner(pubkey)
        merge_account(pubkey, signer: false, writable: true)
      end

      # Add a readonly signer account
      #
      # @param pubkey [Solace::Keypair, Solace::PublicKey, String] The pubkey of the readonly signer account
      def add_readonly_signer(pubkey)
        merge_account(pubkey, signer: true, writable: false)
      end

      # Add a readonly account
      #
      # @param pubkey [Solace::Keypair, Solace::PublicKey, String] The pubkey of the readonly account
      def add_readonly_nonsigner(pubkey)
        merge_account(pubkey, signer: false, writable: false)
      end

      # Predicate to check if an account is a fee payer
      #
      # @param pubkey [String] The pubkey of the account
      # @return [Boolean] Whether the account is a fee payer
      def fee_payer?(pubkey)
        @pubkey_account_map.dig(pubkey, :fee_payer)
      end

      # Predicate to check if an account is a signer
      #
      # @param pubkey [String] The pubkey of the account
      # @return [Boolean] Whether the account is a signer
      def signer?(pubkey)
        @pubkey_account_map.dig(pubkey, :signer)
      end

      # Predicate to check if an account is writable
      #
      # @param pubkey [String] The pubkey of the account
      # @return [Boolean] Whether the account is writable
      def writable?(pubkey)
        @pubkey_account_map.dig(pubkey, :writable)
      end

      # Predicate to check if an account is a writable signer
      #
      # @param pubkey [String] The pubkey of the account
      # @return [Boolean] Whether the account is a writable signer
      def writable_signer?(pubkey)
        (acc = @pubkey_account_map[pubkey]) && acc[:signer] && acc[:writable]
      end

      # Predicate to check if an account is writable and not a signer
      #
      # @param pubkey [String] The pubkey of the account
      # @return [Boolean] Whether the account is writable and not a signer
      def writable_nonsigner?(pubkey)
        (acc = @pubkey_account_map[pubkey]) && !acc[:signer] && acc[:writable]
      end

      # Predicate to check if an account is a readonly signer
      #
      # @param pubkey [String] The pubkey of the account
      # @return [Boolean] Whether the account is a readonly signer
      def readonly_signer?(pubkey)
        (acc = @pubkey_account_map[pubkey]) && acc[:signer] && !acc[:writable]
      end

      # Predicate to check if an account is readonly and not a signer
      #
      # @param pubkey [String] The pubkey of the account
      # @return [Boolean] Whether the account is readonly and not a signer
      def readonly_nonsigner?(pubkey)
        (acc = @pubkey_account_map[pubkey]) && !acc[:signer] && !acc[:writable]
      end

      # Merge all accounts from another AccountContext into this one
      #
      # @param other_context [AccountContext] The other context to merge from
      def merge_from(other_context)
        other_context.pubkey_account_map.each do |pubkey, data|
          signer, writable, fee_payer = data.values_at(:signer, :writable, :fee_payer)
          merge_account(pubkey, signer: signer, writable: writable, fee_payer: fee_payer)
        end
      end

      # Compile accounts into final format
      #
      # Gets unique accounts and sorts them in the following order:
      #   - Signers first (Solana requirement)
      #   - Then writable accounts
      #   - Then readonly accounts
      #
      # @return [Hash] The compiled accounts and header
      def compile
        self.header = calculate_header
        self.accounts = order_accounts
        self
      end

      # Index of a pubkey in the accounts array
      #
      # @param pubkey_str [String] The public key of the account
      # @return [Integer] The index of the pubkey in the accounts array or -1 if not found
      def index_of(pubkey_str)
        indices[pubkey_str] || -1
      end

      # Get map of indicies for pubkeys in accounts array
      #
      # @return [Hash{String => Integer}] The indices of the pubkeys in the accounts array
      def indices
        accounts.each_with_index.to_h
      end

      private

      # Add or merge an account into the context
      #
      # @param pubkey [String, Solace::PublicKey, Solace::Keypair] The public key of the account
      # @param signer [Boolean] Whether the account is a signer
      # @param writable [Boolean] Whether the account is writable
      # @param [Boolean] fee_payer
      def merge_account(pubkey, signer:, writable:, fee_payer: false)
        pubkey_str = pubkey.is_a?(String) ? pubkey : pubkey.address

        @pubkey_account_map[pubkey_str] ||= DEFAULT_ACCOUNT.dup
        @pubkey_account_map[pubkey_str][:signer] ||= signer
        @pubkey_account_map[pubkey_str][:writable] ||= writable
        @pubkey_account_map[pubkey_str][:fee_payer] ||= fee_payer

        self
      end

      # Order accounts by signer, writable, readonly signer, readonly
      #
      # @return [Array<String>] The ordered accounts
      def order_accounts
        @pubkey_account_map.keys.sort_by do |pubkey|
          if fee_payer?(pubkey) then 0
          elsif writable_signer?(pubkey) then 1
          elsif readonly_signer?(pubkey) then 2
          elsif writable_nonsigner?(pubkey) then 3
          elsif readonly_nonsigner?(pubkey) then 4
          else
            raise ArgumentError, "Unknown account type for pubkey: #{pubkey}"
          end
        end
      end

      # Calculate the header for the transaction
      #
      # @note The header is an array of three integers:
      #   - The number of signers (writable + readonly)
      #   - The number of readonly signers
      #   - The number of readonly unsigned accounts
      #
      # @return [Array] The header for the transaction
      def calculate_header
        @pubkey_account_map.keys.each_with_object([0, 0, 0]) do |pubkey, acc|
          acc[0] += 1 if signer?(pubkey)

          if readonly_signer?(pubkey) then acc[1] += 1
          elsif readonly_nonsigner?(pubkey) then acc[2] += 1
          end
        end
      end
    end
  end
end
</file>

<file path="lib/solace/address_lookup_table.rb">
# encoding: ASCII-8BIT
# frozen_string_literal: true

module Solace
  # Represents a Solana Address Lookup Table account.
  #
  # This class models the internal structure of a deserialized address lookup table and provides
  # access to the account key, writable indexes, and readonly indexes.
  #
  # It includes serialization and deserialization logic for encoding and decoding the table
  # according to Solana’s buffer layout.
  #
  # ## Buffer Layout (in bytes):
  # - `[account (32 bytes)]`
  # - `[num_writable (compact-u16)]`
  # - `[writable indexes]`
  # - `[num_readonly (compact-u16)]`
  # - `[readonly indexes]`
  #
  # Includes `BinarySerializable`, enabling methods like `#to_binary`, `#to_io`, and `#to_bytes`.
  #
  # @example Deserialize from base64
  #   io = StringIO.new(base64)
  #   table = Solace::AddressLookupTable.deserialize(io)
  #
  # @example Serialize to base64
  #   table = Solace::AddressLookupTable.new
  #   table.account = pubkey
  #   table.writable_indexes = [1, 2]
  #   table.readonly_indexes = [3, 4]
  #   base64 = table.serialize
  #
  # @since 0.0.1
  class AddressLookupTable
    include Solace::Concerns::BinarySerializable

    # @!attribute [rw] account
    #   @return [String] The account key of the address lookup table
    attr_accessor :account

    # @!attribute [rw] writable_indexes
    #   @return [Array<Integer>] The writable indexes in the address lookup table
    attr_accessor :writable_indexes

    # @!attribute [rw] readonly_indexes
    #   @return [Array<Integer>] The readonly indexes in the address lookup table
    attr_accessor :readonly_indexes

    class << self
      # Deserializes an address lookup table from io stream
      #
      # @param io [IO, StringIO] The input to read bytes from.
      # @return [Solace::AddressLookupTable] Parsed address lookup table object
      def deserialize(io)
        Solace::Serializers::AddressLookupTableDeserializer.new(io).call
      end
    end

    # Serializes the address lookup table
    #
    # @return [String] The serialized address lookup table (base64)
    def serialize
      Solace::Serializers::AddressLookupTableSerializer.new(self).call
    end
  end
end
</file>

<file path="lib/solace/instruction.rb">
# frozen_string_literal: true

module Solace
  # Class representing a Solana instruction.
  #
  # Handles serialization and deserialization of instruction fields. Instructions are used to
  # encode the data that is sent to a program on the Solana blockchain. Instructions are part of
  # transaction messages. All instruction builders and instruction composers return an instance of
  # this class.
  #
  # The BufferLayout is:
  #   - [Program index (1 byte)]
  #   - [Number of accounts (compact u16)]
  #   - [Accounts (variable length)]
  #   - [Data length (compact u16)]
  #   - [Data (variable length)]
  #
  # @example
  #   instruction = Solace::Instruction.new(
  #     program_index: 0,
  #     accounts: [1, 2, 3],
  #     data: [4, 5, 6]
  #   )
  #
  # @since 0.0.1
  class Instruction
    include Solace::Concerns::BinarySerializable

    # @!attribute SERIALIZER
    #   @return [Solace::Serializers::InstructionSerializer] The serializer for the instruction
    SERIALIZER = Solace::Serializers::InstructionSerializer

    # @!attribute DESERIALIZER
    #   @return [Solace::Serializers::InstructionDeserializer] The deserializer for the instruction
    DESERIALIZER = Solace::Serializers::InstructionDeserializer

    # @!attribute  [rw] program_index
    #   @return [Integer] The program index of the instruction
    attr_accessor :program_index

    # @!attribute  [rw] accounts
    #   @return [Array<Integer>] The accounts of the instruction
    attr_accessor :accounts

    # @!attribute  [rw] data
    #   @return [Array<Integer>] The instruction data
    attr_accessor :data
  end
end
</file>

<file path="lib/solace/message.rb">
# frozen_string_literal: true

module Solace
  # Solace::Message represents the message portion of a Solana transaction (legacy or versioned). It handles
  # serialization and deserialization of message fields.
  #
  # @example
  #   message = Solace::Message.new(
  #     version: 0,
  #     header: [0, 0, 0],
  #     accounts: ['11111111111111111111111111111111'],
  #     recent_blockhash: '11111111111111111111111111111111',
  #     instructions: [],
  #     address_lookup_tables: []
  #   )
  #
  # @since 0.0.1
  class Message
    include Solace::Concerns::BinarySerializable

    # @!attribute SERIALIZER
    #   @return [Solace::Serializers::MessageSerializer] The serializer for the message
    SERIALIZER = Solace::Serializers::MessageSerializer

    # @!attribute DESERIALIZER
    #   @return [Solace::Serializers::MessageDeserializer] The deserializer for the message
    DESERIALIZER = Solace::Serializers::MessageDeserializer

    # @!attribute [rw] version
    #   @return [Integer, nil] Message version (nil for legacy)
    attr_accessor :version

    # @!attribute [rw] header
    #   @return [Array<Integer>] Message header [num_required_signatures, num_readonly_signed, num_readonly_unsigned]
    attr_accessor :header

    # @!attribute [rw] accounts
    #   @return [Array<String>] Account public keys (base58)
    attr_accessor :accounts

    # @!attribute [rw] recent_blockhash
    #   @return [String] Recent blockhash (base58)
    attr_accessor :recent_blockhash

    # @!attribute [rw] instructions
    #   @return [Array<Solace::Instruction>] Instructions in the message
    attr_accessor :instructions

    # @!attribute [rw] address_lookup_tables
    #   @return [Array<Solace::AddressLookupTable>] Address lookup tables (for versioned messages)
    attr_accessor :address_lookup_tables

    # Initialize a new Message
    #
    # @param version [Integer, nil] Message version (nil for legacy)
    # @param accounts [Array<String>] Account public keys (base58)
    # @param instructions [Array<Solace::Instruction>] Instructions in the message
    # @param recent_blockhash [String] Recent blockhash (base58)
    # @param header [Array<Integer>] Message header
    # @param address_lookup_tables [Array<Solace::AddressLookupTable>]
    def initialize(
      version: nil,
      accounts: [],
      instructions: [],
      recent_blockhash: nil,
      header: [0, 0, 0],
      address_lookup_tables: []
    )
      super()

      @version = version
      @header = header
      @accounts = accounts
      @recent_blockhash = recent_blockhash
      @instructions = instructions
      @address_lookup_tables = address_lookup_tables
    end

    # Check if the message is versioned
    #
    # @return [Boolean] True if the message is versioned, false otherwise
    def versioned?
      !version.nil?
    end

    # Returns the number of required signatures
    #
    # @return [Integer] The number of required signatures
    def num_required_signatures
      header[0]
    end

    # Returns the number of readonly signed accounts
    #
    # @return [Integer] The number of readonly signed accounts
    def num_readonly_signed_accounts
      header[1]
    end

    # Returns the number of readonly unsigned accounts
    #
    # @return [Integer] The number of readonly unsigned accounts
    def num_readonly_unsigned_accounts
      header[2]
    end
  end
end
</file>

<file path="test/factories/instruction_factory.rb">
# frozen_string_literal: true

# require 'factory_bot'

FactoryBot.define do
  factory :instruction, class: 'Solace::Instruction' do
    # Instruction type
    program_index { nil }
    accounts { [] }
    data { [] }

    trait :as_transfer do
      program_index { 2 }
      accounts { [0, 1] }
      data { [2, 0, 0, 0] + [100_000_000].pack('Q<').bytes }
    end

    trait :as_transfer_checked do
      program_index { 2 }
      accounts { [0, 1] }
      data { [12] + [100_000_000].pack('Q<').bytes + [6] }
    end

    trait :as_create_account do
      program_index { 2 }
      accounts { [0, 1] }
      data do
        [0, 0, 0,
         0] + [1_000_000_000].pack('Q<').bytes + [100].pack('Q<').bytes + [Solace::Constants::SYSTEM_PROGRAM_ID].pack('H*')
      end
    end
  end
end
</file>

<file path="test/solace/instructions/associated_token_account/create_associated_token_account_instruction_test.rb">
# frozen_string_literal: true

require 'test_helper'

describe Solace::Instructions::AssociatedTokenAccount::CreateAssociatedTokenAccountInstruction do
  describe '.build' do
    let(:ix) do
      Solace::Instructions::AssociatedTokenAccount::CreateAssociatedTokenAccountInstruction.build(
        funder_index: 0,
        associated_token_account_index: 1,
        owner_index: 2,
        mint_index: 3,
        system_program_index: 4,
        token_program_index: 5,
        program_index: 6
      )
    end

    it 'should build a valid instruction' do
      assert_kind_of Solace::Instruction, ix
    end

    it 'should have the correct program index' do
      assert_equal 6, ix.program_index
    end

    it 'should have the correct accounts' do
      assert_equal [0, 1, 2, 3, 4, 5], ix.accounts
    end

    it 'should have the correct data' do
      assert_equal [0], ix.data
    end
  end

  describe 'account creation' do
    let(:conn) { Solace::Connection.new }

    let(:mint) { Fixtures.load_keypair('mint') }
    let(:payer) { Fixtures.load_keypair('payer') }

    let(:owner) { Solace::Keypair.generate }

    before(:all) do
      # 1. Derive the Associated Token Account (ATA) address
      # This is a Program Derived Address (PDA), so we find it before creating it.
      ata_address, = Solace::Utils::PDA.find_program_address(
        [
          owner.address,
          Solace::Constants::TOKEN_PROGRAM_ID,
          mint.address
        ],
        Solace::Constants::ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID
      )

      # 2. Define the master list of accounts for the transaction in the correct order.
      # The instruction's account indices will refer to this list.
      accounts = [
        payer.address,          # 0: Funder (Payer), writable, signer
        ata_address,            # 1: New ATA, writable
        owner.address,          # 2: Owner, readonly
        mint.address,           # 3: Mint, readonly
        Solace::Constants::SYSTEM_PROGRAM_ID, # 4: System Program, readonly
        Solace::Constants::TOKEN_PROGRAM_ID,                   # 5: SPL Token Program, readonly
        Solace::Constants::ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID # 6: The program we are calling
      ]

      # 3. Build the instruction, providing the index of each required account.
      instruction = Solace::Instructions::AssociatedTokenAccount::CreateAssociatedTokenAccountInstruction.build(
        funder_index: 0,
        associated_token_account_index: 1,
        owner_index: 2,
        mint_index: 3,
        system_program_index: 4,
        token_program_index: 5,
        program_index: 6
      )

      # 4. Build the message
      message = Solace::Message.new(
        header: [1, 0, 4], # 1 signer (payer), 4 readonly accounts
        accounts: accounts,
        recent_blockhash: conn.get_latest_blockhash,
        instructions: [instruction]
      )

      # 5. Build and sign the transaction
      tx = Solace::Transaction.new(message: message)
      tx.sign(payer)

      # 6. Send the transaction and verify success
      response = conn.send_transaction(tx.serialize)
      conn.wait_for_confirmed_signature { response }

      # 7. Get account info
      @account_info = conn.get_account_info(ata_address)
    end

    it 'account should be owned by the token program' do
      assert_equal Solace::Constants::TOKEN_PROGRAM_ID, @account_info['owner']
    end

    it 'account should have 165 bytes of blockspace' do
      assert_equal 165, @account_info['space']
    end

    it 'account should not be executable' do
      assert_equal false, @account_info['executable']
    end
  end
end
</file>

<file path="test/solace/instructions/spl_token/transfer_instruction_test.rb">
# frozen_string_literal: true

require 'test_helper'

describe Solace::Instructions::SplToken::TransferInstruction do
  let(:connection) { Solace::Connection.new }
  let(:spl_token_program) { Solace::Programs::SplToken.new(connection: connection) }
  let(:associated_token_account_program) { Solace::Programs::AssociatedTokenAccount.new(connection: connection) }

  let(:mint) { Fixtures.load_keypair('mint') }
  let(:mint_authority) { Fixtures.load_keypair('mint-authority') }

  let(:payer) { Fixtures.load_keypair('payer') }
  let(:source_owner) { Fixtures.load_keypair('bob') }
  let(:destination_owner) { Fixtures.load_keypair('anna') }

  let(:amount) { 1_000_000_000 }

  describe '.build' do
    let(:ix) do
      Solace::Instructions::SplToken::TransferInstruction.build(
        amount: amount,
        source_index: 1,
        destination_index: 2,
        owner_index: 0,
        program_index: 3
      )
    end

    it 'builds a valid instruction' do
      assert_kind_of Solace::Instruction, ix
    end

    it 'has the correct program index' do
      assert_equal 3, ix.program_index
    end

    it 'has the correct accounts' do
      assert_equal [1, 2, 0], ix.accounts
    end

    it 'has the correct data' do
      assert_equal Solace::Instructions::SplToken::TransferInstruction.data(amount), ix.data
    end
  end

  describe 'on-chain test' do
    let(:source) { Solace::Programs::AssociatedTokenAccount.get_address(owner: source_owner, mint: mint).first }
    let(:destination) { Solace::Programs::AssociatedTokenAccount.get_address(owner: destination_owner, mint: mint).first }

    before(:all) do
      # # Create ata for source and destination
      # @destination = associated_token_account_program.create_associated_token_account(owner: destination_owner, mint:, payer:)

      # Create mint, source ATA, and mint tokens
      connection.wait_for_confirmed_signature do
        spl_token_program.mint_to(
          amount: amount,
          payer: payer,
          mint: mint,
          destination: source,
          mint_authority: mint_authority
        )['result']
      end

      # Accounts
      accounts = [
        payer.address,
        source_owner.address,
        source,
        destination,
        Solace::Constants::TOKEN_PROGRAM_ID
      ]

      # Instruction
      ix = Solace::Instructions::SplToken::TransferInstruction.build(
        amount: amount,
        source_index: 2,
        destination_index: 3,
        owner_index: 1,
        program_index: 4
      )

      # Message
      message = Solace::Message.new(
        header: [2, 0, 1],
        accounts: accounts,
        instructions: [ix],
        recent_blockhash: connection.get_latest_blockhash
      )

      # Transaction
      tx = Solace::Transaction.new(message: message)
      tx.sign(payer, source_owner)

      # Send transaction
      connection.wait_for_confirmed_signature do
        @response = connection.send_transaction(tx.serialize)
        @response['result']
      end
    end

    it 'returns a valid signature' do
      assert_includes 84..88, @response['result'].length
    end
  end
end
</file>

<file path="test/solace/serializers/instruction_deserializer_test.rb">
# frozen_string_literal: true

require_relative '../../test_helper'

describe Solace::Serializers::InstructionDeserializer do
  # Build a transfer instruction
  let(:ix) do
    Solace::Instructions::SystemProgram::TransferInstruction.build(
      to_index: 1,
      from_index: 0,
      program_index: 2,
      lamports: 100_000_000
    )
  end

  describe '#call' do
    before do
      @deserialized_ix = Solace::Serializers::InstructionDeserializer.new(ix.to_io).call
    end

    it 'returns a deserialized instruction' do
      assert_kind_of Solace::Instruction, @deserialized_ix
    end

    it 'has the correct accounts' do
      assert_equal @deserialized_ix.accounts, [0, 1]
    end

    it 'has the correct program index' do
      assert_equal @deserialized_ix.program_index, 2
    end

    it 'has the correct data' do
      assert_equal @deserialized_ix.data, Solace::Instructions::SystemProgram::TransferInstruction.data(100_000_000)
    end
  end
end
</file>

<file path="test/solace/serializers/instruction_serializer_test.rb">
# frozen_string_literal: true

require_relative '../../test_helper'

describe Solace::Serializers::InstructionSerializer do
  # Build a transfer instruction
  let(:ix) do
    Solace::Instructions::SystemProgram::TransferInstruction.build(
      to_index: 1,
      from_index: 0,
      program_index: 2,
      lamports: 100_000_000
    )
  end

  describe '#call' do
    before do
      @serialized_ix = Solace::Serializers::InstructionSerializer.new(ix).call
    end

    it 'returns a serialized instruction' do
      assert_kind_of String, @serialized_ix
    end

    it 'has the correct structure' do
      assert_operator @serialized_ix.bytesize, :>, 0
    end
  end
end
</file>

<file path="test/solace/utils/account_context_test.rb">
# frozen_string_literal: true

require 'test_helper'

describe Solace::Utils::AccountContext do
  let(:context) { Solace::Utils::AccountContext.new }

  let(:pubkey1) { keypair1.address }
  let(:pubkey2) { keypair2.address }
  let(:pubkey3) { keypair3.address }
  let(:keypair1) { Solace::Keypair.generate }
  let(:keypair2) { Solace::Keypair.generate }
  let(:keypair3) { Solace::Keypair.generate }
  let(:program_id) { Solace::Constants::TOKEN_PROGRAM_ID }

  describe '#initialize' do
    it 'initializes with empty accounts and header' do
      assert_empty context.accounts
      assert_empty context.header
    end
  end

  describe '#set_fee_payer' do
    before do
      context.set_fee_payer(keypair1)
    end

    it 'adds fee payer account with correct permissions' do
      assert context.fee_payer?(pubkey1)
      assert context.writable?(pubkey1)
    end

    it 'adds fee payer account as first account after compilation' do
      context.add_writable_nonsigner(pubkey2)
      context.add_readonly_nonsigner(pubkey3)

      context.compile

      assert_equal pubkey1, context.accounts[0]
    end
  end

  describe '#add_writable_nonsigner' do
    before do
      context.add_writable_nonsigner(pubkey1)
    end

    it 'adds writable account with correct permissions' do
      refute context.fee_payer?(pubkey1)
      assert context.writable?(pubkey1)
      assert context.writable_nonsigner?(pubkey1)
    end
  end

  describe '#add_readonly_nonsigner' do
    before do
      context.add_readonly_nonsigner(pubkey1)
    end

    it 'adds readonly account with correct permissions' do
      refute context.fee_payer?(pubkey1)
      refute context.writable?(pubkey1)
      assert context.readonly_nonsigner?(pubkey1)
    end
  end

  describe 'account merging and deduplication' do
    it 'merges same pubkey with upgraded permissions' do
      # Start with readonly
      context.add_readonly_nonsigner(pubkey1)
      assert context.readonly_nonsigner?(pubkey1)

      # Upgrade to writable
      context.add_writable_nonsigner(pubkey1)
      assert context.writable_nonsigner?(pubkey1)
      refute context.readonly_nonsigner?(pubkey1)

      # Upgrade to fee payer
      context.set_fee_payer(keypair1)
      assert context.fee_payer?(pubkey1)
      refute context.writable_nonsigner?(pubkey1)
    end

    it 'preserves existing fee payer status when adding lower permissions' do
      context.set_fee_payer(keypair1)
      context.add_readonly_nonsigner(pubkey1)

      # Should still be a fee payer
      assert context.fee_payer?(pubkey1)
    end

    it 'preserves existing writable status when adding readonly' do
      context.add_writable_nonsigner(pubkey1)
      context.add_readonly_nonsigner(pubkey1)

      # Should still be writable
      assert context.writable_nonsigner?(pubkey1)
      refute context.readonly_nonsigner?(pubkey1)
    end
  end

  describe '#compile' do
    before do
      context.set_fee_payer(keypair1)
      context.add_writable_nonsigner(pubkey2)
      context.add_readonly_nonsigner(program_id)
      context.add_readonly_nonsigner('mint_pubkey')

      context.compile
    end

    it 'returns accounts in correct order' do
      assert_equal 4, context.accounts.length
      assert_equal pubkey1, context.accounts[0] # Fee payer first
      # Other accounts follow in deterministic order
    end

    it 'calculates correct header' do
      # keypair1 (fee payer) = 1 writable signer → acc[0]
      # pubkey2 (writable nonsigner) = not counted (implementation bug)
      # program_id + mint_pubkey = 2 readonly nonsigners → acc[2]
      assert_equal [1, 0, 2], context.header
    end

    it 'builds correct account indices mapping' do
      indices = context.indices

      assert_equal 0, indices[pubkey1] # Fee payer is first
      assert_kind_of Integer, indices[pubkey2]
      assert_kind_of Integer, indices[program_id]
      assert_kind_of Integer, indices['mint_pubkey']

      # All indices should be unique and within range
      all_indices = indices.values
      assert_equal all_indices.uniq, all_indices
      assert(all_indices.all? { |i| i >= 0 && i < 4 })
    end
  end

  describe '#merge_from' do
    let(:other_context) { Solace::Utils::AccountContext.new }

    before do
      # Setup other context
      other_context.set_fee_payer(keypair1)
      other_context.add_writable_nonsigner(pubkey2)

      # Setup main context with overlapping account
      context.add_readonly_nonsigner(pubkey1) # Same pubkey, lower permissions
      context.add_readonly_nonsigner('mint_pubkey')
    end

    it 'merges accounts from another context' do
      # Arrange other context
      other_context.set_fee_payer(keypair1)
      other_context.add_writable_signer(pubkey2)
      other_context.add_readonly_nonsigner('system_program_id_1111')

      context.merge_from(other_context)

      # Should upgrade pubkey1 to fee payer
      assert context.fee_payer?(pubkey1)

      # Should add pubkey2 as writable signer
      assert context.writable_signer?(pubkey2)

      # Should preserve existing system program account
      assert context.readonly_nonsigner?('system_program_id_1111')
    end
  end

  describe 'complex scenarios' do
    it 'handles multiple fee payers correctly' do
      context.set_fee_payer(keypair1)
      context.add_writable_nonsigner(pubkey2)

      context.compile

      assert_equal [1, 0, 0], context.header
      assert_includes context.accounts, pubkey1
    end

    it 'handles account deduplication correctly' do
      # Add same pubkey multiple times with different permissions
      context.add_readonly_nonsigner(pubkey1)
      context.add_writable_nonsigner(pubkey1) # Should upgrade to writable
      context.set_fee_payer(keypair1) # Should upgrade to fee payer
      context.add_readonly_nonsigner(pubkey2)

      context.compile

      # Should only have 2 unique accounts
      assert_equal 2, context.accounts.length

      # pubkey1 should be fee payer
      assert context.fee_payer?(pubkey1)

      # pubkey2 should be readonly nonsigner
      assert context.readonly_nonsigner?(pubkey2)
    end

    it 'sorts accounts deterministically' do
      # Add in mixed order
      context.add_readonly_nonsigner('mint_pubkey')
      context.add_writable_nonsigner('dest_pubkey')
      context.add_readonly_nonsigner(program_id)
      context.set_fee_payer(keypair1)

      context.compile

      # Should be ordered: fee payer, writable nonsigners, readonly nonsigners
      assert context.fee_payer?(context.accounts[0]) # keypair1
      assert context.writable?(context.accounts[1]) # dest_pubkey
    end
  end

  describe '#index_of' do
    before do
      context.set_fee_payer(keypair1)
      context.add_writable_nonsigner(pubkey2)

      context.compile
    end

    it 'returns correct index for pubkey string' do
      assert_equal 0, context.index_of(pubkey1)
      assert_equal 1, context.index_of(pubkey2)
    end

    it 'returns -1 for non-existent pubkey' do
      assert_equal(-1, context.index_of('non_existent_pubkey'))
    end
  end

  describe 'edge cases' do
    it 'handles empty context compilation' do
      context.compile

      assert_equal([], context.accounts)
      assert_equal({}, context.indices)
      assert_equal([0, 0, 0], context.header)
    end

    it 'handles single account' do
      context.set_fee_payer(keypair1)

      context.compile

      assert_equal 1, context.accounts.length
      assert_equal pubkey1, context.accounts[0]
      assert_equal [1, 0, 0], context.header
    end

    it 'handles string and keypair pubkey formats consistently' do
      context.add_writable_nonsigner(pubkey1) # String
      context.add_writable_nonsigner(keypair1) # Keypair (same pubkey)

      context.compile

      assert_equal 1, context.accounts.length
      assert_equal [0, 0, 0], context.header
      assert_equal pubkey1, context.accounts[0]
    end
  end
end
</file>

<file path="test/solace/utils/pda_test.rb">
# frozen_string_literal: true

require 'test_helper'

describe Solace::Utils::PDA do
  describe '#find_program_address' do
    # The expected PDA addresses and their corresponding seeds and program IDs. These
    # values were generated using the Solana kit at https://solana.com/docs/core/pda
    let(:pda_addresses) do
      [
        {
          # My Program PDA
          pda_address: 'CZ7UF6XZRvp9EQ7Wo3yxzxJZrJWpUuYrdFgGt7svMBXy',
          bump: 255,
          seeds: %w[MySeed],
          program_id: 'MyProgram1111111111111111111111111111111111'
        },
        {
          # ZAR Escrow PDA devnet
          pda_address: '4wBgoYaMWu9yVAoLp3MqTbjtGLbLrK7HGkUhAfag64xv',
          bump: 255,
          seeds: %w[
            escrow_deposit
            FRgEYVCueFxFeqq3vP7WrHgvnz8YRoBDz2SshoLz8U7Q
          ],
          program_id: '5Y3yGEVqbZJDn41YnVETMbTt8yq4HKreVkS6X3cxErvH'
        },
        {
          # Associated Token Account PDA
          pda_address: 'GeQiE41zi17u5ENDEWetKSBkrgVneZYo6qCLbtyDSVbZ',
          bump: 255,
          seeds: %w[
            7uKbd92U6LgAvXGvFgMAmgmgG1FmqwzBRsBN6KKcE2R4
            TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
            EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v
          ],
          program_id: 'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL'
        },
        {
          # Off Curve with Bump address
          pda_address: '3J9UVhG3K8To1CCwFjstWRDyFzhu2ytehrygKgNemwk9',
          bump: 253,
          seeds: %w[FindRandomBump_],
          program_id: '5Y3yGEVqbZJDn41YnVETMbTt8yq4HKreVkS6X3cxErvH'
        },
        {
          # Another Off Curve with Bump address
          pda_address: 'CWSM8UbEALk2MAxbkg5tNVMXia9F2Lq2fXD6e5iHFn5n',
          bump: 251,
          seeds: [
            'wallet_account',
            102,
            'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v'
          ],
          program_id: '3LkGTjNsF2zWc2ddBPHYyEJJZKqbdHJDgfjztxnjwL5R'
        },
        {
          # Another Off Curve with Bump address
          pda_address: 'G3Zss7LJgpAFj1wpT9aT4FrkRd47Hso6tUEMJas4USpR',
          bump: 245,
          seeds: [
            '$user_account_id',
            [374],
            'Rq7zLIpy0ETAgOMuWEUzD3Ic'
          ],
          program_id: '3LkGTjNsF2zWc2ddBPHYyEJJZKqbdHJDgfjztxnjwL5R'
        }
      ]
    end

    it 'finds the PDA address and bump' do
      pda_addresses.each do |pda_address|
        address, bump = Solace::Utils::PDA.find_program_address(
          pda_address[:seeds],
          pda_address[:program_id]
        )

        assert_equal pda_address[:bump], bump
        assert_equal pda_address[:pda_address], address
      end
    end
  end
end
</file>

<file path="test/solace/keypair_test.rb">
# frozen_string_literal: true

require 'test_helper'
require 'base58'

describe Solace::Keypair do
  let(:klass) { Solace::Keypair }

  describe '.generate' do
    before do
      @keypair = klass.generate
    end

    it 'creates a valid keypair' do
      assert_kind_of klass, @keypair
    end
  end

  describe '.from_seed' do
    before do
      @seed = 'a' * 32
    end

    it 'creates a deterministic keypair' do
      keypair1 = klass.from_seed(@seed)
      keypair2 = klass.from_seed(@seed)

      assert_equal keypair1.address, keypair2.address
    end
  end

  describe '.from_secret_key' do
    before do
      @keypair = klass.generate
    end

    it 'creates a keypair from a secret' do
      secret = @keypair.keypair_bytes.pack('C*')
      keypair2 = klass.from_secret_key(secret)

      assert_equal @keypair.address, keypair2.address
    end
  end

  describe '#sign' do
    before do
      @keypair = klass.generate
    end

    it 'produces a valid signature' do
      signature = @keypair.sign('hello')

      assert_kind_of String, signature
      assert_equal 64, signature.bytesize
    end

    it 'signature changes with message' do
      sig1 = @keypair.sign('msg1')
      sig2 = @keypair.sign('msg2')

      assert sig1 != sig2
    end
  end

  describe '#public_key_bytes' do
    before do
      @keypair = klass.generate
    end

    it 'returns the public key bytes of the keypair' do
      assert_equal @keypair.public_key_bytes, @keypair.keypair_bytes[32..63]
    end
  end

  describe '#private_key_bytes' do
    before do
      @keypair = klass.generate
    end

    it 'returns the private key bytes of the keypair' do
      assert_equal @keypair.private_key_bytes, @keypair.keypair_bytes[0..31]
    end
  end

  describe '#to_base58' do
    before do
      @keypair = klass.generate
    end

    it 'returns the public key of the keypair as a Base58 string' do
      assert_equal @keypair.to_base58, @keypair.public_key.to_base58
    end
  end

  describe '#to_s' do
    before do
      @keypair = klass.generate
    end

    it 'returns the public key as a Base58 string' do
      assert_equal @keypair.to_base58, @keypair.to_s
    end
  end

  describe '#address' do
    before do
      @keypair = klass.generate
    end

    it 'returns the public key as a Base58 string' do
      assert_equal @keypair.to_base58, @keypair.address
    end
  end
end
</file>

<file path="test/solace/public_key_test.rb">
# frozen_string_literal: true

require 'test_helper'

describe Solace::PublicKey do
  before do
    # Example 32-byte key (all 1s)
    @bytes = Array.new(32, 1)
    @base58 = Solace::Utils::Codecs.bytes_to_base58(@bytes)
    @public_key = Solace::PublicKey.new(@bytes)
  end

  describe '#initialize' do
    it 'accepts 32-byte array' do
      assert_equal @bytes, @public_key.bytes
    end

    it 'raises on invalid length' do
      assert_raises(ArgumentError) { Solace::PublicKey.new([1, 2, 3]) }
    end
  end

  describe '#to_base58' do
    it 'returns base58 representation' do
      base58 = @public_key.to_base58
      assert_equal @base58, base58
    end
  end

  describe '#address' do
    it 'returns base58 representation' do
      assert_equal @base58, @public_key.address
    end
  end

  describe '#to_s' do
    it 'returns base58 representation' do
      assert_equal @base58, @public_key.to_s
    end
  end

  describe '#==' do
    it 'returns true for equal keys' do
      pk2 = Solace::PublicKey.new(@bytes.dup)
      refute_nil pk2
      assert_equal @public_key, pk2
    end

    it 'returns false for different keys' do
      pk3 = Solace::PublicKey.new(Array.new(32, 2))
      refute_equal @public_key, pk3
    end
  end

  describe '#to_s' do
    it 'returns base58 representation' do
      assert_equal @base58, @public_key.to_s
    end
  end

  describe '#to_bytes' do
    it 'returns copy o bytes' do
      bytes_copy = @public_key.to_bytes
      assert_equal @bytes, bytes_copy
      refute_same @public_key.bytes, bytes_copy
    end
  end

  describe '.from_address' do
    it 'returns public key instance from base58 address' do
      pk4 = Solace::PublicKey.from_address(@base58)

      assert_equal @public_key, pk4
    end

    it 'raises on invalid address' do
      assert_raises(ArgumentError) { Solace::PublicKey.from_address('invalid_address') }
    end
  end
end
</file>

<file path="README.md">
# Solace Ruby SDK Documentation
A Ruby SDK for the Solana blockchain.

## Overview

Solace is a comprehensive Ruby SDK for interacting with the Solana blockchain. It provides both low-level building blocks and high-level abstractions for composing, signing, and sending Solana transactions. The library aims to follow Ruby conventions while maintaining compatibility with Solana's binary protocols.

## Architecture

The Solace SDK is organized into several key layers:

### 1. **Core Classes** (Low-Level)
- **Keypair/PublicKey**: Ed25519 cryptographic operations
- **Connection**: RPC client for Solana nodes
- **Transaction/Message/Instruction/AddressLookupTable**: Transaction building blocks
- **Serializers**: Binary serialization/deserialization system

### 2. **Instruction Builders** (Low-Level)
- Service objects that build specific instruction types
- Handle binary data encoding and account indexing
- Located in `lib/solace/instructions/`

### 3. **Composers** (High-Level)
- Convenient interfaces for composing transactions and instructions
- Handle account ordering and header calculations for transactions
- Located in `lib/solace/composers`

### 3. **Programs** (High-Level)
- Convenient interfaces for interacting with on-chain programs
- Handle transaction assembly, signing, and submission
- Located in `lib/solace/programs/`

### 4. **Utilities** (Support modules & classes)
- **Codecs**: Base58/Base64 encoding, compact integers, little-endian encoding
- **PDA**: Program Derived Address generation
- **Curve25519**: Native curve operations via FFI
- **More...**: Checkout `lib/solace/utils` 

## Core Components

### Transaction & Message

Transactions contain a message and signatures. Messages contain instructions and metadata. This core class is as simple as possible and provide the lowest level of abstraction for building and sending transactions. A developer is expected to:

1. Manually fill and order the accounts array
2. Manually fill and order the instructions array
3. Manually calculate the header
4. ...did I forget to say manually?

```ruby
# Create a message
message = Solace::Message.new(
    header: [
        1, # required_signatures
        0, # readonly_signed
        1  # readonly_unsigned
    ],
    accounts: [
        payer.address,
        recipient.address,
        system_program_id
    ],
    instructions: [transfer_instruction],
    recent_blockhash: connection.get_latest_blockhash,
)

# Create and sign transaction
transaction = Solace::Transaction.new(message: message)
transaction.sign(payer_keypair)

# Send transaction
signature = connection.send_transaction(transaction.serialize)
```

**Key Features:**
- Legacy and versioned transaction support
- Automatic signature management
- Binary serialization/deserialization
- Address lookup table support (versioned)

### Instruction

Instructions represent individual operations within a transaction. Like messages, instructions are as simple as possible and provide the lowest level of abstraction for building and sending transactions. A developer is expected to:

1. Manually fill and order the accounts indices array
2. Manually specify the program index
3. Manually specify the data

```ruby
instruction = Solace::Instruction.new(
    program_index: 2,  # Index in accounts array
    accounts: [0, 1],  # Account indices
    data: [2, 0, 0, 0] + amount_bytes  # Instruction data
)

# All instructions have accessor methods for program_index, accounts, and data
instruction.program_index # => 2
instruction.accounts # => [0, 1]
instruction.data # => [2, 0, 0, 0] + amount_bytes
```

**Key Features:**
- Program index referencing
- Account index arrays
- Binary data payload
- Serializable format

## Low-Level Instruction Builders

Given that the low-level instruction class is fully available, it's easy to build higher-level instruction builders that wrap the low-level instruction class. These builders are service objects that create specific instruction types. They handle the binary encoding required by Solana programs.

For example, the SystemProgram::TransferInstruction builder is a service object that creates and returns a Solace::Instruction object with the correct program index, accounts indices, and data for a System Program solana transfer.

```ruby
# Build a SOL transfer instruction
transfer_ix = Solace::Instructions::SystemProgram::TransferInstruction.build(
  lamports: 1_000_000,  # 0.001 SOL
  from_index: 0,        # Sender account index
  to_index: 1,          # Recipient account index
  program_index: 2      # System program index
)
```

Solace includes a number of these, and you can build your own as well.

- `Solace::Instructions::SystemProgram::TransferInstruction`
- `Solace::Instructions::SystemProgram::CreateAccountInstruction`
- `Solace::Instructions::SplToken::InitializeMintInstruction`
- `Solace::Instructions::SplToken::InitializeAccountInstruction`
- `Solace::Instructions::SplToken::MintToInstruction`
- `Solace::Instructions::SplToken::TransferInstruction`
- `Solace::Instructions::SplToken::TransferCheckedInstruction`
- `Solace::Instructions::AssociatedTokenAccount::CreateAssociatedTokenAccountInstruction`

**Common Patterns:**
- All builders use `.build()` class method
- All builders use `.data()` method to specify the instruction data
- All builders use named parameters and `_index` suffix for account indices
- All builders use a `program_index` parameter to specify the program index
- Account indices reference the transaction's accounts array
- Binary data encoding handled automatically
- Instruction-specific data layouts documented in comments

## High-Level Program Classes

**WARNING: Programs will probably get deprecated in favor of composers in the future.**

Now that we have the mid-level instruction builders, we can create high-level program classes that provide convenient interfaces for common operations, handling transaction assembly, signing, and submission.

For example, the `Solace::Programs::SplToken` class provides a high-level interface for interacting with the SPL Token Program.

### SPL Token Program

```ruby
# Initialize program client
spl_token = Solace::Programs::SplToken.new(connection: connection)

# Create a new token mint
response = spl_token.create_mint(
  payer: payer_keypair,
  decimals: 6,
  mint_authority: authority_keypair,
  freeze_authority: freeze_keypair,  # Optional
  mint_keypair: mint_keypair         # Optional, generates if not provided
)
connection.wait_for_confirmed_signature { response['result'] }

# Mint tokens to an account
response = spl_token.mint_to(
  payer: payer_keypair,
  mint: mint_keypair,
  destination: token_account_address,
  amount: 1_000_000,
  mint_authority: authority_keypair
)
connection.wait_for_confirmed_signature { response['result'] }

# Transfer tokens
response = spl_token.transfer(
  payer: payer_keypair,
  source: source_token_account,
  destination: dest_token_account,
  amount: 500_000,
  owner: owner_keypair
)
connection.wait_for_confirmed_signature { response['result'] }
```

**Key Features:**
- Automatic transaction assembly
- Built-in signing and submission
- Error handling and validation
- Sensible defaults for common operations
- Returns transaction signatures

### Prepare Methods

For more control, use "prepare" methods that return signed transactions without sending it on the program:

```ruby
# Prepare transaction without sending
transaction = spl_token.prepare_create_mint(
  payer: payer_keypair,
  decimals: 6,
  mint_authority: authority_keypair,
  freeze_authority: nil,
  mint_keypair: mint_keypair
)

# Inspect or modify transaction before sending
puts transaction.serialize  # Base64 transaction
signature = connection.send_transaction(transaction.serialize)
```

## Utility Modules

### Codecs

The `Solace::Utils::Codecs` module provides encoding/decoding utilities for Solana data types.

```ruby
# Base58 operations
base58_string = Solace::Utils::Codecs.bytes_to_base58(bytes)
bytes = Solace::Utils::Codecs.base58_to_bytes(base58_string)

# Compact u16 encoding (ShortVec)
encoded = Solace::Utils::Codecs.encode_compact_u16(1234)
value, bytes_read = Solace::Utils::Codecs.decode_compact_u16(io)

# Little-endian u64
encoded = Solace::Utils::Codecs.encode_le_u64(amount)
value = Solace::Utils::Codecs.decode_le_u64(io)

# Base64 to IO stream
io = Solace::Utils::Codecs.base64_to_bytestream(base64_string)
```

### Program Derived Addresses (PDA)

```ruby
# Find PDA with bump seed
seeds = ['metadata', mint_address, 'edition']
program_id = 'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s'

address, bump = Solace::Utils::PDA.find_program_address(seeds, program_id)
```

**Key Features:**
- Automatic bump seed finding
- Multiple seed type support (String, Integer, Array)
- Base58 address detection
- SHA256 hashing with curve validation

### Curve25519 Operations

```ruby
# Check if point is on curve (used in PDA validation)
on_curve = Solace::Utils::Curve25519Dalek.on_curve?(32_byte_point)
```

## Constants

**WARNING: Constants will probably get deprecated in favor of config file that developers can use to define their own constants with required values.**

Common Solana program IDs are defined in `Solace::Constants`:

```ruby
Solace::Constants::SYSTEM_PROGRAM_ID                    # '11111111111111111111111111111111'
Solace::Constants::TOKEN_PROGRAM_ID                     # 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'
Solace::Constants::ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID  # 'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL'
Solace::Constants::SYSVAR_RENT_PROGRAM_ID               # 'SysvarRent111111111111111111111111111111111'
Solace::Constants::MEMO_PROGRAM_ID                      # 'MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'
```

## Composers

Composers are used to build transactions from multiple instructions. They handle all the low-level details of transaction assembly, such as account ordering, header calculation, and fee payer selection.

```ruby
# Initialize a transaction composer
composer = Solace::TransactionComposer.new(connection: connection)

# Add an instruction composer
composer.add_instruction(
  Solace::Composers::SystemProgramTransferComposer.new(
    to: 'pubkey1',
    from: 'pubkey2',
    lamports: 100
  )
)

# Add another instruction composer
composer.add_instruction(
  Solace::Composers::SplTokenProgramTransferCheckedComposer.new(
    from: 'pubkey4',
    to: 'pubkey5',
    mint: 'pubkey6',
    authority: 'pubkey7',
    amount: 1_000_000,
    decimals: 6
  )
)

# Set the fee payer
composer.set_fee_payer('pubkey8')

# Compose the transaction
tx = composer.compose_transaction

# Sign the transaction with all required signers
tx.sign(*any_required_signers)
```

Composers are intended to be extended by developers with custom instruction composers to interface with their own programs. Simply inherit from `Solace::Composers::Base` and implement the required methods.

```ruby
class MyProgramComposer < Solace::Composers::Base
  # All keyword arguments are passed to the constructor and available
  # as a `params` hash.
  # 
  # The setup_accounts method is called automatically by the transaction composer
  # during compilation and should be used to add accounts to the account_context 
  # with the appropriate access permissions. Conditional logic is fine here given 
  # and available params to determine the access permissions.
  def setup_accounts
    account_context.add_writable_signer(params[:from])
    account_context.add_writable_nonsigner(params[:to])
    account_context.add_readonly_nonsigner(params[:program])
  end

  # The build_instruction method is called automatically by the transaction composer
  # during compilation and should be used to build the instruction using an instruction builder.
  # 
  # The passed context to the build_instruction method provides the indices of all accounts
  # that were added to the account_context in the setup_accounts method. These are accessible
  # by the index_of method of the context using the account address as a parameter.
  def build_instruction(context)
    Solace::Instructions::MyProgram::MyInstruction.build(
      data: params[:data],
      from_index: context.index_of(params[:from]),
      to_index: context.index_of(params[:to]),
      program_index: context.index_of(params[:program])
    )
  end
end
```

## Practical Examples

### Complete SOL Transfer

```ruby
require 'solace'

# Setup
payer = Solace::Keypair.generate
recipient = Solace::Keypair.generate

# Create connection
connection = Solace::Connection.new('https://api.devnet.solana.com')

# Fund payer (devnet only)
response = connection.request_airdrop(payer.address, 1_000_000_000)
connection.wait_for_confirmed_signature('finalized') { response['result'] }

# Build transfer instruction
transfer_ix = Solace::Instructions::SystemProgram::TransferInstruction.build(
  lamports: 100_000_000,  # 0.1 SOL
  from_index: 0,
  to_index: 1,
  program_index: 2
)

# Create message
message = Solace::Message.new(
  accounts: [
    payer.address,
    recipient.address,
    Solace::Constants::SYSTEM_PROGRAM_ID
  ],
  instructions: [transfer_ix],
  recent_blockhash: connection.get_latest_blockhash,
  header: [1, 0, 1]
)

# Sign and send
transaction = Solace::Transaction.new(message: message)
transaction.sign(payer)

response = connection.send_transaction(transaction.serialize)
puts "Transaction: #{response['result']}"
```

### Complete Token Mint Creation

```ruby
require 'solace'

# Setup
payer = Solace::Keypair.generate
mint_keypair = Solace::Keypair.generate

# Create connection
connection = Solace::Connection.new('https://api.devnet.solana.com')

# Fund payer
response = connection.request_airdrop(payer.address, 1_000_000_000)
connection.wait_for_confirmed_signature('finalized') { response['result'] }

# High-level approach
program = Solace::Programs::SplToken.new(connection: connection)
signature = program.create_mint(
  payer: payer,
  decimals: 6,
  mint_authority: payer,
  freeze_authority: nil,
  mint_keypair: mint_keypair
)

puts "Mint created: #{mint_keypair.address}"
puts "Transaction: #{signature}"
```

## Design Patterns

### Service Objects
Instruction builders follow the service object pattern:
- Single responsibility (build one instruction type)
- Class methods for stateless operations
- Consistent `.build()` interface
- Separate `.data()` methods for instruction data

## Testing Support

The SDK includes comprehensive test utilities:

```ruby
# Test fixtures for keypairs
bob = Fixtures.load_keypair('bob')
alice = Fixtures.load_keypair('anna')

# Automatic funding in test environment
response = connection.request_airdrop(keypair.address, 10_000_000_000)
connection.wait_for_confirmed_signature { response['result'] }

# Transaction confirmation helpers
response = connection.send_transaction(transaction.serialize)
connection.wait_for_confirmed_signature { response['result'] }
```

## Dependencies

- **base58**: Base58 encoding/decoding
- **base64**: Base64 encoding/decoding
- **rbnacl**: Ed25519 cryptography
- **ffi**: Foreign Function Interface for native libraries
- **json**: JSON parsing for RPC
- **net/http**: HTTP client for RPC calls

## Current Limitations

### High-Impact/Foundational Next Steps

1. **Associated Token Account Program**
   - Implement: close_associated_token_account, and helpers for derivation.
   - Rationale: Required for user wallets and token UX. **Most SPL Token operations depend on ATAs to be useful in real-world workflows.**

2. **Full SPL Token Program Coverage** _(depends on ATA support)_
   - Implement: mint_to, burn, close_account, set_authority, freeze/thaw, approve/revoke, etc.
   - Rationale: Most dApps and DeFi protocols rely on SPL tokens. **For practical use, SPL Token instructions should leverage ATA helpers.**

3. **Account Data Parsing**
   - Implement: Decoders for token accounts, mint accounts, stake accounts, etc.
   - Rationale: Needed to read on-chain state.

4. **Transaction Simulation**
   - Implement: `simulateTransaction` RPC endpoint.
   - Rationale: Allows dry-run and error debugging.

5. **Error Decoding**
   - Implement: Map program error codes to readable errors.
   - Rationale: Improves DX and debugging.

---

### Medium-Impact

6. **Address Lookup Table Support**
   - Implement: Create, extend, use ALT in transactions.
   - Rationale: Needed for scalable DeFi/protocols.

7. **Stake Program**
   - Implement: delegate, deactivate, withdraw, split, merge.
   - Rationale: For validators, staking dApps.

8. **Websocket/Event Subscription**
   - Implement: Account/slot/transaction subscriptions.
   - Rationale: For real-time apps and bots.

9. **Utility Functions**
   - base58/base64 encode/decode, lamports/SOL conversions, etc.

10. **Advanced Transaction Features**
    - Durable nonce, versioned transactions, partial signing.

---

### Low-Impact/Advanced

- Governance program
- Anchor IDL/Anchor-style program support
- Program deployment (BPF loader)

## Conclusion

Solace provides a comprehensive, Ruby-idiomatic interface to the Solana blockchain. Its layered architecture allows developers to choose the appropriate level of abstraction for their needs, from low-level instruction building to high-level program interactions. The consistent patterns and thorough documentation make it accessible to Ruby developers while maintaining the power and flexibility needed for complex Solana applications.
</file>

<file path="lib/solace/instructions/system_program/create_account_instruction.rb">
# frozen_string_literal: true

module Solace
  module Instructions
    module SystemProgram
      # Instruction for creating a new account.
      #
      # This instruction is used to create a new account for a given program.
      #
      # @example Build a CreateAccount instruction
      #   instruction = Solace::Instructions::SystemProgram::CreateAccountInstruction.build(
      #     space: 1024,
      #     lamports: 1000,
      #     from_index: 0,
      #     new_account_index: 1,
      #     owner: owner.address,
      #     system_program_index: 2
      #   )
      #
      # @since 0.0.2
      class CreateAccountInstruction
        # @!attribute [Array<Integer>] INSTRUCTION_INDEX
        #   Instruction index for SystemProgram::CreateAccount
        #   This is the same across all Solana clusters
        INSTRUCTION_INDEX = [0, 0, 0, 0].freeze

        # Builds a SystemProgram::CreateAccount instruction
        #
        # @param space [Integer] Number of bytes to allocate for the new account
        # @param lamports [Integer] Amount of lamports to fund the new account
        # @param owner [String] The program_id of the owner of the new account
        # @param from_index [Integer] Index of the funding account (payer) in the transaction's accounts
        # @param new_account_index [Integer] Index of the new account to create in the transaction's accounts
        # @param system_program_index [Integer] Index of the system program in the transaction's accounts (default: 2)
        # @return [Solace::Instruction]
        def self.build(
          space:,
          lamports:,
          from_index:,
          new_account_index:,
          owner: Solace::Constants::SYSTEM_PROGRAM_ID,
          system_program_index: 2
        )
          Solace::Instruction.new.tap do |ix|
            ix.program_index = system_program_index
            ix.accounts = [from_index, new_account_index]
            ix.data = data(lamports, space, owner)
          end
        end
        # rubocop:enable Metrics/ParameterLists

        # Builds the data for a SystemProgram::CreateAccount instruction
        #
        # The BufferLayout is:
        #   - [Instruction Index (4 bytes)]
        #   - [Lamports (8 bytes)]
        #   - [Space (8 bytes)]
        #   - [Owner (32 bytes)]
        #
        # @param lamports [Integer] Amount of lamports to fund the new account
        # @param space [Integer] Number of bytes to allocate for the new account
        # @param owner [String] The program_id of the owner of the new account
        # @return [Array] 4-byte instruction index + 8-byte lamports + 8-byte space + 32-byte owner
        def self.data(lamports, space, owner)
          INSTRUCTION_INDEX +
            Solace::Utils::Codecs.encode_le_u64(lamports).bytes +
            Solace::Utils::Codecs.encode_le_u64(space).bytes +
            Solace::Utils::Codecs.base58_to_bytes(owner)
        end
      end
    end
  end
end
</file>

<file path="lib/solace/serializers/message_deserializer.rb">
# frozen_string_literal: true

module Solace
  module Serializers
    # Deserializes a binary message into a Solace::Message object.
    #
    # @since 0.0.1
    class MessageDeserializer < Solace::Serializers::BaseDeserializer
      # @!attribute record_class
      #   The class of the record being deserialized
      #
      # @return [Class] The class of the record
      self.record_class = Solace::Message

      # @!attribute steps
      #   An ordered list of methods to deserialize the message
      #
      # @return [Array] The steps to deserialize the message
      self.steps = %i[
        next_extract_version
        next_extract_message_header
        next_extract_accounts
        next_extract_recent_blockhash
        next_extract_instructions
        next_extract_address_lookup_table
      ]

      # Extract version from the message
      #
      # Checks for version prefix and extracts version. If the prefix is not found, it
      # assumes a legacy message and sets no version.
      #
      # The BufferLayout is:
      #   - [Version prefix (1 byte)]
      #   - [Version (variable length)]
      #
      # @return [Integer] The version of the message
      def next_extract_version
        next_byte = io.read(1).unpack1('C')

        if next_byte & 0x80 == 0x80
          record.version = next_byte & 0x7F
        else
          io.seek(-1, IO::SEEK_CUR)
          record.version = nil
        end
      end

      # Extract message header from the message
      #
      # The BufferLayout is:
      #   - [Message header (3 bytes)]
      #
      # @return [Array<Integer>] The message header of the message
      def next_extract_message_header
        record.header = io.read(3).bytes
      end

      # Extract account keys from the message
      #
      # The BufferLayout is:
      #   - [Number of accounts (compact u16)]
      #   - [Accounts (variable length u8)]
      #
      # @return [Array<String>] The account keys of the message
      def next_extract_accounts
        count, = Codecs.decode_compact_u16(io)
        record.accounts = count.times.map do
          Codecs.bytes_to_base58 io.read(32).bytes
        end
      end

      # Extract recent blockhash from the message
      #
      # The BufferLayout is:
      #   - [Recent blockhash (32 bytes)]
      #
      # @return [String] The recent blockhash of the message
      def next_extract_recent_blockhash
        record.recent_blockhash = Codecs.bytes_to_base58 io.read(32).bytes
      end

      # Extract instructions from the message
      #
      # The BufferLayout is:
      #   - [Number of instructions (compact u16)]
      #   - [Instructions (variable length)]
      #
      # @return [Array<Solace::Instruction>] The instructions of the message
      def next_extract_instructions
        count, = Codecs.decode_compact_u16(io)
        record.instructions = count.times.map do
          Solace::Instruction.deserialize(io)
        end
      end

      # Extract address lookup table from the message
      #
      # The BufferLayout is:
      #   - [Number of address lookup tables (compact u16)]
      #   - [Address lookup tables (variable length)]
      #
      # @return [Array<Solace::AddressLookupTable>] The address lookup table of the message
      def next_extract_address_lookup_table
        return unless record.versioned?

        count, = Codecs.decode_compact_u16(io)
        record.address_lookup_tables = count.times.map do
          Solace::AddressLookupTable.deserialize(io)
        end
      end
    end
  end
end
</file>

<file path="lib/solace/utils/codecs.rb">
# frozen_string_literal: true

require 'base64'
require 'rbnacl'
require 'base58'
require 'stringio'

module Solace
  module Utils
    # Module for encoding and decoding data
    #
    # @since 0.0.1
    module Codecs
      # Creates a StringIO from a base64 string.
      #
      # @param base64 [String] The base64 string to decode
      # @return [StringIO] A StringIO object containing the decoded bytes
      def self.base64_to_bytestream(base64)
        StringIO.new(Base64.decode64(base64))
      end

      # Encodes a compact-u16 value in a compact form (shortvec)
      #
      # @param u16 [Integer] The compact-u16 value to encode
      # @return [String] The compactly encoded compact-u16 value
      def self.encode_compact_u16(u16)
        out = []

        loop do
          # In general, n >> 7 shifts the bits of n to the right by
          # 7 positions, effectively dividing n by 128 and discarding
          # the remainder (integer division). This is commonly used in
          # encoding schemes to process one "byte" (7 bits) at a time.
          if (u16 >> 7).zero?
            out << u16
            break
          end
          # The expression out << ((n & 0x7F) | 0x80) is used in variable-length
          # integer encoding, such as the compact-u16 encoding.
          #
          # n & 0x7F:
          #   - 0x7F is 127 in decimal, or 0111 1111 in binary.
          #   - n & 0x7F masks out all but the lowest 7 bits of n. This extracts the least significant 7 bits of n.
          #
          # (n & 0x7F) | 0x80:
          #   - 0x80 is 128 in decimal, or 1000 0000 in binary.
          #   - | (bitwise OR) sets the highest bit (the 8th bit) to 1.
          #   - This is a signal that there are more bytes to come in the encoding (i.e., the value hasn't been fully
          #     encoded yet).
          #
          # out << ...:
          #   - This appends the resulting byte to the out array.
          out << ((u16 & 0x7F) | 0x80)
          u16 >>= 7
        end

        out.pack('C*')
      end

      # Decodes a compact-u16 (ShortVec) value from an IO-like object.
      #
      # Reads bytes one at a time, accumulating the result until the MSB is 0.
      #
      # @param stream [IO, StringIO] The input to read bytes from.
      # @return [Integer, Integer] The decoded value and the number of bytes read.
      def self.decode_compact_u16(stream)
        value = 0
        shift = 0
        bytes_read = 0

        loop do
          byte = stream.read(1)
          raise EOFError, 'Unexpected end of input while decoding compact-u16' unless byte

          byte = byte.ord
          value |= (byte & 0x7F) << shift
          bytes_read += 1
          break if byte.nobits?(0x80)

          shift += 7
        end

        [value, bytes_read]
      end

      # Encodes a u64 value in little-endian format
      #
      # @param u64 [Integer] The u64 value to encode
      # @return [String] The little-endian encoded u64 value
      def self.encode_le_u64(u64)
        [u64].pack('Q<') # 64-bit little-endian
      end

      # Decodes a little-endian u64 value from a sequence of bytes
      #
      # @param stream [IO, StringIO] The input to read bytes from.
      # @return [Integer] The decoded u64 value
      def self.decode_le_u64(stream)
        stream.read(8).unpack1('Q<')
      end

      # Encodes a sequence of bytes in Base58 format
      #
      # @param binary [String] The bytes to encode
      # @return [String] The Base58 encoded string
      def self.binary_to_base58(binary)
        Base58.binary_to_base58(binary, :bitcoin)
      end

      # Decodes a Base58 string into a binary string
      #
      # @param string [String] The Base58 encoded string
      # @return [String] The decoded binary string
      def self.base58_to_binary(string)
        base58_to_bytes(string).pack('C*')
      end

      # Encodes a sequence of bytes in Base58 format
      #
      # @param bytes [String] The bytes to encode
      # @return [String] The Base58 encoded string
      def self.bytes_to_base58(bytes)
        binary_to_base58(bytes.pack('C*'))
      end

      # Decodes a Base58 string into a sequence of bytes
      #
      # @param string [String] The Base58 encoded string
      # @return [String] The decoded bytes
      def self.base58_to_bytes(string)
        Base58.base58_to_binary(string, :bitcoin).bytes
      end

      # Checks if a string is a valid Base58 string
      #
      # @param string [String] The string to check
      # @return [Boolean] True if the string is a valid Base58 string, false otherwise
      def self.valid_base58?(string)
        return false if string.nil? || string.empty?

        Base58.decode(string)
        true
      rescue StandardError => _e
        false
      end
    end
  end
end
</file>

<file path="test/solace/instructions/system_program/create_account_instruction_test.rb">
# frozen_string_literal: true

require 'test_helper'

describe Solace::Instructions::SystemProgram::CreateAccountInstruction do
  describe 'build' do
    let(:space) { 100 }
    let(:lamports) { 1_000_000_000 }
    let(:owner) { Solace::Constants::SYSTEM_PROGRAM_ID }

    let(:ix) do
      Solace::Instructions::SystemProgram::CreateAccountInstruction.build(
        space: space,
        lamports: lamports,
        owner: owner,
        from_index: 0,
        new_account_index: 1,
        system_program_index: 2
      )
    end

    it 'should build a valid instruction' do
      assert_kind_of Solace::Instruction, ix
    end

    it 'should have the correct program index' do
      assert_equal 2, ix.program_index
    end

    it 'should have the correct accounts' do
      assert_equal [0, 1], ix.accounts
    end

    it 'should have the correct data' do
      assert_equal(
        [0, 0, 0, 0] +
        [lamports].pack('Q<').bytes +
        [space].pack('Q<').bytes +
        Solace::Utils::Codecs.base58_to_bytes(owner),
        ix.data
      )
    end
  end

  describe 'with custom program index' do
    let(:ix_with_custom_program_index) do
      Solace::Instructions::SystemProgram::CreateAccountInstruction.build(
        space: 100,
        lamports: 1_000_000_000,
        owner: Solace::Constants::SYSTEM_PROGRAM_ID,
        from_index: 0,
        new_account_index: 1,
        system_program_index: 3
      )
    end

    it 'should have the correct program index' do
      assert_equal 3, ix_with_custom_program_index.program_index
    end
  end

  describe 'account creation' do
    let(:conn) { Solace::Connection.new }

    let(:payer) { Fixtures.load_keypair('payer') }
    let(:new_account) { Solace::Keypair.generate }

    let(:space) { 100 }
    let(:owner) { Solace::Constants::SYSTEM_PROGRAM_ID }
    let(:lamports) { conn.get_minimum_lamports_for_rent_exemption(space) }

    before(:all) do
      # 1. Build instruction
      instruction = Solace::Instructions::SystemProgram::CreateAccountInstruction.build(
        owner: owner,
        space: space,
        lamports: lamports,
        from_index: 0,
        new_account_index: 1,
        system_program_index: 2
      )

      # 2. Build message
      message = Solace::Message.new(
        header: [
          2, # num_required_signatures
          0, # num_readonly_signed
          1  # num_readonly_unsigned
        ],
        accounts: [
          payer.address,
          new_account.address,
          Solace::Constants::SYSTEM_PROGRAM_ID
        ],
        recent_blockhash: conn.get_latest_blockhash,
        instructions: [instruction]
      )

      # 3. Build transaction
      transaction = Solace::Transaction.new(message: message)

      transaction.sign(payer, new_account)

      # 4. Send transaction
      conn.wait_for_confirmed_signature do
        response = conn.send_transaction(transaction.serialize)

        response['result']
      end

      # 5. Get account info
      @account_info = conn.get_account_info(new_account.address)
    end

    it 'account should not be executable' do
      assert_equal false, @account_info['executable']
    end

    it 'account should have correct owner' do
      assert_equal owner, @account_info['owner']
    end

    it 'account should have correct space' do
      assert_equal space, @account_info['space']
    end

    it 'account should have correct lamports' do
      assert_equal lamports, @account_info['lamports']
    end
  end
end
</file>

<file path="test/solace/programs/spl_token_test.rb">
# frozen_string_literal: true

require 'test_helper'

describe Solace::Programs::SplToken do
  let(:klass) { Solace::Programs::SplToken }
  let(:connection) { Solace::Connection.new }
  let(:program) { klass.new(connection: connection) }

  describe '#initialize' do
    it 'assigns connection' do
      assert_equal program.connection, connection
    end

    it 'assigns program_id' do
      assert_equal program.program_id, Solace::Constants::TOKEN_PROGRAM_ID
    end
  end

  describe 'create a token mint' do
    let(:decimals) { 6 }
    let(:payer) { Fixtures.load_keypair('payer') }

    let(:mint_keypair) { Solace::Keypair.generate }
    let(:mint_authority) { Solace::Keypair.generate }
    let(:freeze_authority) { Solace::Keypair.generate }

    describe '#prepare_create_mint' do
      let(:tx) do
        program.prepare_create_mint(
          payer: payer,
          decimals: decimals,
          mint_keypair: mint_keypair,
          mint_authority: mint_authority,
          freeze_authority: freeze_authority
        )
      end

      it 'should prepare a transaction' do
        assert_kind_of Solace::Transaction, tx
      end

      it 'should sign the transaction with the payer and mint authority' do
        assert_equal tx.signatures.length, 2

        # First account is payer
        assert_equal tx.message.accounts[0], payer.address

        # Second account is mint keypair
        assert_equal tx.message.accounts[1], mint_keypair.address
      end

      it 'should set the correct header' do
        assert_equal tx.message.header, [2, 0, 3]
      end

      it 'should order the accounts correctly' do
        assert_equal(
          tx.message.accounts,
          [
            payer.address,
            mint_keypair.address,
            Solace::Constants::SYSVAR_RENT_PROGRAM_ID,
            Solace::Constants::TOKEN_PROGRAM_ID,
            Solace::Constants::SYSTEM_PROGRAM_ID
          ]
        )
      end
      it 'should create two instructions (CreateAccountInstruction and InitializeMintInstruction)' do
        assert_equal tx.message.instructions.length, 2
      end
    end

    describe '#create_mint' do
      before(:all) do
        # 1. Create the mint and await confirmation
        connection.wait_for_confirmed_signature do
          response = program.create_mint(
            payer: payer,
            decimals: decimals,
            mint_keypair: mint_keypair,
            mint_authority: mint_authority,
            freeze_authority: freeze_authority
          )

          response['result']
        end

        # 5. Get account info
        @account_info = connection.get_account_info(mint_keypair.address)
      end

      it 'account should not be executable' do
        assert_equal @account_info['executable'], false
      end

      it 'account should have 82 bytes of blockspace' do
        assert_equal @account_info['space'], 82
      end

      it 'account should be owned by the token program' do
        assert_equal @account_info['owner'], Solace::Constants::TOKEN_PROGRAM_ID
      end
    end
  end

  describe 'mint tokens' do
    let(:amount) { 1_000_000 }

    let(:mint) { Fixtures.load_keypair('mint') }
    let(:owner) { Fixtures.load_keypair('bob') }
    let(:payer) { Fixtures.load_keypair('payer') }
    let(:mint_authority) { Fixtures.load_keypair('mint-authority') }

    let(:destination) do
      ata_address, = Solace::Programs::AssociatedTokenAccount.get_address(owner: owner, mint: mint)
      ata_address
    end

    describe '#prepare_mint_to' do
      let(:tx) do
        program.prepare_mint_to(
          amount: amount,
          mint: mint,
          payer: payer,
          destination: destination,
          mint_authority: mint_authority
        )
      end

      it 'should prepare a transaction' do
        assert_kind_of Solace::Transaction, tx
      end

      describe 'when the mint authority is not the payer' do
        it 'should sign the transaction with the payer and mint authority' do
          assert_equal tx.signatures.length, 2
          assert_equal tx.message.accounts[0], payer.address
          assert_equal tx.message.accounts[1], mint_authority.address
        end
      end

      describe 'when the mint authority is the payer' do
        let(:mint_authority) { payer }

        it 'should sign the transaction with the payer' do
          assert_equal tx.signatures.length, 1
          assert_equal tx.message.accounts[0], payer.address
        end
      end
    end

    describe '#mint_to' do
      before(:all) do
        connection.wait_for_confirmed_signature do
          @result = program.mint_to(
            amount: amount,
            mint: mint,
            payer: payer,
            destination: destination,
            mint_authority: mint_authority
          )

          @result['result']
        end
      end

      it 'should return a valid signature' do
        assert_includes 84..88, @result['result'].length
      end
    end
  end

  describe 'transfer tokens' do
    let(:amount) { 1_000_000 }

    let(:payer) { Fixtures.load_keypair('payer') }
    let(:source_owner) { Fixtures.load_keypair('bob') }
    let(:destination_owner) { Fixtures.load_keypair('anna') }

    let(:mint) { Fixtures.load_keypair('mint') }
    let(:mint_authority) { Fixtures.load_keypair('mint-authority') }

    let(:source) { Solace::Programs::AssociatedTokenAccount.get_address(owner: source_owner, mint: mint).first }
    let(:destination) { Solace::Programs::AssociatedTokenAccount.get_address(owner: destination_owner, mint: mint).first }

    describe '#prepare_transfer' do
      let(:tx) do
        program.prepare_transfer(
          amount: amount,
          payer: payer,
          source: source,
          owner: source_owner,
          destination: destination
        )
      end

      it 'should prepare a transaction' do
        assert_kind_of Solace::Transaction, tx
      end
    end

    describe '#transfer' do
      before(:all) do
        @response = program.transfer(
          amount: amount,
          payer: payer,
          source: source,
          owner: source_owner,
          destination: destination
        )

        connection.wait_for_confirmed_signature { @response['result'] }
      end

      it 'should return a valid signature' do
        assert_includes 84..88, @response['result'].length
      end
    end
  end
end
</file>

<file path="test/solace/transaction_test.rb">
# frozen_string_literal: true

require 'test_helper'

describe Solace::Transaction do
  before do
    # Constants
    @legacy_tx_base64 = 'AQTOlTZsUqzg6u0IVycmib4bKX7B2T3NcojpY41cl/eEiAASMp3Jw2BRxHjljjzkYIaJ9riCZGaJPs8d1epyqgwBAAQH66k2oxCf1NeH/qx+lTO8hVJaIRFdbOZ9gcllmRxaOY4ePuaeKDiITwFZ8rCSkE+db/L5QJy0xGAauYopfRdP4V8H9slNVtuqE+OCdY1zzix2FyAYSUozZZvscFh9+YmDAwZGb+UhFzL/7K26csOb57yM5bvF9xJrLEObOkAAAAAG3fbh12Whk9nL4UbO63msHLSF7V9bN5E6jPWFfv8AqSKtWWLMxAr/lb3bGSFoFz4J32rEnvAT3IaBkhYHxQ+aO0Qss5EhV/E6kz0BNCgtAytf/s0Botvxt3kGCN8ALqd+cK7yZ+2vzULI/dD7q+Kko7KdVLNIL3Fdfxhts2TjigMDAAUCNCEAAAMACQMgoQcAAAAAAAQGAgYBAAAFCgwQJwAAAAAAAAY='
    @versioned_tx_base64 = 'Aaq/sJpfXp/rur6pUDoniGGiqJr9VnsjNjPgB/nF7yct/yvZDkZK83NVm35gngpQXVG8PScoCPZgd0rGrK1b9QSAAQADC5kYZngZ374Y0pb6toNS8GHchmk84eLPpT4FJYf5crqoHSD5PZKUQwLgiCHryaf8nYk/9Al8YGxaabuPi6YsD7E417niAzAcHpomUF/GETKHRYOgv/P1/BLiytOES8dmZqGhggNSUXM2XTqsvfg3BSoR82hoDtF5DPfMmxCnw9kDJjx8nnqzm2jnudUkmtT7OefnKxmLLPwmxna0+Ur5JyNmFYSl4ZtUmvGPp0x4olkD8HeiBYjO1miLKcSNaSmFs2m8wpNK/w2erNxNBqLyr4Ug7KVaSU0C5Mfzx9IdUpl+Z/n96hEZ1/m4PAL+pZejjM0ChyLCm8l9UMVuyGThaW8DBkZv5SEXMv/srbpyw5vnvIzlu8X3EmssQ5s6QAAAAEPgBQCBHk9mdcAVjyWfKoLRkuYzPGFr1h8etE0/GSomBHnVLe2/a8Xs0J2EU0o0rqWXUEOzb9ArJGULtYRDWVx9jg0F4KP4uEEqvdsAUZCEMfqzYLqwiV0Msd0Ri7lW6gQIAAkDAQAAAAAAAAAIAAUCs3QJAAobGwAWHRsAARYEBQYHAwMJHRsADxYRBRACAgIcJuUXy5d6460qAAIAAAACEQECEQCZzggAAAAAAJnOCAAAAAAAAAAAChkbABYfGx4gABYUFRcTEhobGBkAFw4LFgwNJOUXy5d6460qAAIAAAACAwIDcP0/AAAAAABw/T8AAAAAAAAAAARAZBKwJRxRnGTsI+T6zu8hUOLI6lctSWvf4+Ycva/8GQTf4ePkBODi5QKEgS7T31AwSpZVXVVwlUfGebniA/eoCIKFzzwMS83eFAN+WlsCfVmHN+v4qZMpECh9knvF52aQMItF99mqKn4VgxJJ0eR3EQT7+Pr8A/79+SlzukoCCkEx+Sj3pIVWahbnIjqag3d4ZCeUmaJnBlAsAqANAA=='

    # IOs
    legacy_io = Solace::Utils::Codecs.base64_to_bytestream(@legacy_tx_base64)
    versioned_io = Solace::Utils::Codecs.base64_to_bytestream(@versioned_tx_base64)

    # Transactions
    @legacy_tx = Solace::Transaction.deserialize(legacy_io)
    @versioned_tx = Solace::Transaction.deserialize(versioned_io)
  end

  describe '#serialize' do
    it 'returns serialized legacy transaction' do
      assert_equal @legacy_tx_base64, @legacy_tx.serialize
    end

    it 'returns serialized versioned transaction' do
      assert_equal @versioned_tx_base64, @versioned_tx.serialize
    end
  end

  describe 'Multiple Signatures' do
    # Make sure keypairs are loaded
    let(:bob) { Fixtures.load_keypair('bob') }
    let(:alice) { Fixtures.load_keypair('anna') }
    let(:payer) { Fixtures.load_keypair('payer') }

    let(:nobody) { Solace::Keypair.generate }
    let(:unknown_signer) { Solace::Keypair.generate }

    # Make sure connection is loaded
    let(:conn) { Solace::Connection.new }

    before do
      # Arrange
      @msg = Solace::Message.new

      # 1 signer will serve as payer
      # 1 signer will be account 1
      # 1 signer will be account 2
      @msg.header = [
        3,
        0,
        1
      ]

      # Add accounts
      @msg.accounts = [
        payer.address,
        bob.address,
        alice.address,
        nobody.address,
        Solace::Constants::SYSTEM_PROGRAM_ID
      ]

      # Get latest blockhash
      @msg.recent_blockhash = conn.get_latest_blockhash

      @msg.instructions = [
        # Send money from account 1 to account 2
        Solace::Instructions::SystemProgram::TransferInstruction.build(
          to_index: 2,
          from_index: 1,
          program_index: 4,
          lamports: 10_000_000 # 0.01 SOL
        ),
        # Send money from account 2 to account 3
        Solace::Instructions::SystemProgram::TransferInstruction.build(
          to_index: 3,
          from_index: 2,
          program_index: 4,
          lamports: 10_000_000 # 0.01 SOL
        )
      ]

      @tx = Solace::Transaction.new(message: @msg)
    end

    it 'should add multiple signatures to the transaction' do
      @tx.sign(payer, bob, alice)

      assert_equal 3, @tx.signatures.size
    end

    it 'should reject unpresent signers' do
      error = assert_raises(ArgumentError) { @tx.sign(unknown_signer) }
      assert_equal 'Public key not found in transaction', error.message
    end

    it 'should order the signatures according to the accounts' do
      # NOTE: The ording of this test is important, as it simulates a
      # transaction where the order by which signatures get added being
      # random, while the transaction still being valid.

      alice_signature = @tx.sign(alice).first
      # Alice is account 2 at index 2 of the accounts array
      assert_equal alice_signature, @tx.signatures[2]

      payer_signature = @tx.sign(payer).first
      # Payer is account 0 at index 0 of the accounts array
      assert_equal payer_signature, @tx.signatures[0]

      bob_signature = @tx.sign(bob).first
      # Bob is account 1 at index 1 of the accounts array
      assert_equal bob_signature, @tx.signatures[1]
    end

    it 'should handle placeholder signatures' do
      @tx.signatures = 3.times.map { Solace::Utils::Codecs.base58_to_binary('1' * 64) }

      bob_signature = @tx.sign(bob).first
      # Bob is account 1 at index 1 of the accounts array
      assert_equal bob_signature, @tx.signatures[1]

      # First handoff: Simulate a transaction being sent to another server or node
      one_of_three_signed_tx = Solace::Transaction.from(@tx.serialize)

      alice_signature = one_of_three_signed_tx.sign(alice).first
      # Alice is account 2 at index 2 of the accounts array
      assert_equal alice_signature, one_of_three_signed_tx.signatures[2]

      # Second handoff: Simulate a transaction being sent to another server or node
      two_of_three_signed_tx = Solace::Transaction.from(one_of_three_signed_tx.serialize)

      payer_signature = two_of_three_signed_tx.sign(payer).first
      # Payer is account 0 at index 0 of the accounts array
      assert_equal payer_signature, two_of_three_signed_tx.signatures[0]

      # Third handoff: Simulate a transaction being sent to another server or node
      three_of_three_signed_tx = Solace::Transaction.from(two_of_three_signed_tx.serialize)

      # All signatures should be present
      assert_equal 3, three_of_three_signed_tx.signatures.size
    end

    it 'should successfully send a transaction' do
      # Sign the transaction
      @tx.sign(bob)
      @tx.sign(alice)

      # In a Solana transaction, the first signature (payer) in the signatures array gets
      # used as the signature of the transaction. If the returned result is equal to the
      # signature of the payer, the transaction was successfully sent.
      raw_payer_signature = @tx.sign(payer).first

      # Convert the signature to base58
      encoded_payer_signature = Solace::Utils::Codecs.binary_to_base58(raw_payer_signature)

      # Send the transaction
      conn.wait_for_confirmed_signature do
        response = conn.send_transaction(@tx.serialize)

        assert_equal encoded_payer_signature, response['result']

        # Return the result signature to the block
        response['result']
      end
    end
  end
end
</file>

<file path="test/usecases/test_token_transfer_sdk.rb">
# frozen_string_literal: true

# test_token_transfer_sdk.rb

require 'test_helper'
require 'base58'
require_relative '../../lib/solace/instructions/transfer_checked_instruction'

# TODO: Implement these helpers in your SDK for full SPL token support:
# - Solace::SPL.create_mint
# - Solace::SPL.create_associated_token_account
# - Solace::SPL.mint_to

bob = JSON.load_file(File.expand_path('../fixtures/bob.json', __dir__))
anna = JSON.load_file(File.expand_path('../fixtures/anna.json', __dir__))

sender = Solace::Keypair.from_secret_key(bob.pack('C*'))
Solace::Keypair.from_secret_key(anna.pack('C*'))

conn = Solace::Connection.new

# Use pre-created mint and token accounts (set these as environment variables or constants)
mint = '5TdHBognPcuumzVbcp6SfqDbkceGLAGbNYfP4yXpVJPA'
sender_token_account = 'HE4UYNGU19nxrVr4hzq1HQDn45A8QRmMX1gJubVHq8Vz'
recipient_token_account = 'D2t6jATJHqpAAH46XAmL7JHThGWqv56Lz8AiPwhT1Mez'

# Optionally, print these for debugging
puts "Mint: #{mint}"

puts 'Sender token balance before:'
puts `spl-token balance --owner ./test/fixtures/bob.json #{mint}`

puts 'Recipient token balance before:'
puts `spl-token balance --owner ./test/fixtures/anna.json #{mint}`

# 5. Build SPL token transfer instruction
instruction = Solace::Instructions::SplToken::TransferCheckedInstruction.build(
  amount: 100,
  decimals: 6,
  from_index: 1,      # sender_token_account
  to_index: 2,        # recipient_token_account
  authority_index: 0, # sender (authority)
  mint_index: 3,      # mint
  program_index: 4    # SPL Token program
)

# 6. Build transaction
accounts = [
  sender.address,
  sender_token_account,
  recipient_token_account,
  mint,
  Solace::Constants::TOKEN_PROGRAM_ID
]

message = Solace::Message.new(
  header: [
    1, # num_required_signatures
    0, # num_readonly_signed
    2 # num_readonly_unsigned
  ],
  accounts: accounts,
  recent_blockhash: conn.get_latest_blockhash,
  instructions: [instruction]
)

# 7. Build transaction
transaction = Solace::Transaction.new(message: message)
transaction.sign(sender)

# 8. Send transaction
result = conn.send_transaction(transaction.serialize)
puts "Token transfer transaction sent: #{result}"
</file>

<file path="lib/solace/composers/system_program_transfer_composer.rb">
# frozen_string_literal: true

module Solace
  module Composers
    # Composer for creating a system program transfer instruction.
    #
    # This composer resolves and orders the required accounts for a `Transfer` instruction,
    # sets up their access permissions, and delegates construction to the appropriate
    # instruction builder (`Instructions::SystemProgram::TransferInstruction`).
    #
    # It is used for transferring lamports from one account to another.
    #
    # Required accounts:
    # - **From**: source account (writable, signer)
    # - **To**: destination account (writable, non-signer)
    # - **Program**: System program (readonly, non-signer)
    #
    # @example Compose and build a transfer instruction
    #   composer = SystemProgramTransferComposer.new(
    #     from: from_address,
    #     to: to_address,
    #     lamports: 1_000_000
    #   )
    #
    # @see Instructions::SystemProgram::TransferInstruction
    # @since 0.0.3
    class SystemProgramTransferComposer < Base
      # Extracts the to address from the params
      #
      # @return [String] The to address
      def to
        params[:to].to_s
      end

      # Extracts the from address from the params
      #
      # @return [String] The from address
      def from
        params[:from].to_s
      end

      # Returns the system program id
      #
      # @return [String] The system program id
      def system_program
        Solace::Constants::SYSTEM_PROGRAM_ID.to_s
      end

      # Returns the lamports to transfer
      #
      # @return [Integer] The lamports to transfer
      def lamports
        params[:lamports]
      end

      # Setup accounts required for transfer instruction
      # Called automatically during initialization
      #
      # @return [void]
      def setup_accounts
        account_context.add_writable_signer(from)
        account_context.add_writable_nonsigner(to)
        account_context.add_readonly_nonsigner(system_program)
      end

      # Build instruction with resolved account indices
      #
      # @param account_context [Utils::AccountContext] The account context
      # @return [Solace::Instruction]
      def build_instruction(account_context)
        Instructions::SystemProgram::TransferInstruction.build(
          lamports: lamports,
          to_index: account_context.index_of(to),
          from_index: account_context.index_of(from),
          program_index: account_context.index_of(system_program)
        )
      end
    end
  end
end
</file>

<file path="lib/solace/instructions/system_program/transfer_instruction.rb">
# frozen_string_literal: true

module Solace
  module Instructions
    module SystemProgram
      # Instruction for transferring SOL.
      #
      # This instruction is used to transfer SOL from one account to another.
      #
      # @example Build a Transfer instruction
      #   instruction = Solace::Instructions::SystemProgram::TransferInstruction.build(
      #     lamports: 100,
      #     to_index: 1,
      #     from_index: 2,
      #     program_index: 3
      #   )
      #
      # @since 0.0.2
      class TransferInstruction
        # Instruction ID for System Transfer
        INSTRUCTION_ID = [2, 0, 0, 0].freeze

        # Builds a Solace::Instruction for transferring SOL
        #
        # @param lamports [Integer] Amount to transfer (in lamports)
        # @param to_index [Integer] Index of the recipient in the transaction's accounts
        # @param from_index [Integer] Index of the sender in the transaction's accounts
        # @param program_index [Integer] Index of the program in the transaction's accounts (default: 2)
        # @return [Solace::Instruction]
        def self.build(
          lamports:,
          to_index:,
          from_index:,
          program_index: 2
        )
          Instruction.new.tap do |ix|
            ix.program_index = program_index
            ix.accounts = [from_index, to_index]
            ix.data = data(lamports)
          end
        end

        # Instruction data for a transfer instruction
        #
        # The BufferLayout is:
        #   - [Instruction ID (4 bytes)]
        #   - [Amount (8 bytes little-endian u64)]
        #
        # @param lamports [Integer] Amount to transfer (in lamports)
        # @return [Array] 4-byte instruction ID + 8-byte amount
        def self.data(lamports)
          INSTRUCTION_ID +
            Utils::Codecs.encode_le_u64(lamports).bytes
        end
      end
    end
  end
end
</file>

<file path="lib/solace/programs/spl_token.rb">
# frozen_string_literal: true

module Solace
  module Programs
    # Client for interacting with the SPL Token Program.
    #
    # This client provides methods for interacting with the SPL Token Program. It is a wrapper around
    # the SPL Token Program and provides a more convenient interface for creating and managing SPL
    # Token mints and accounts.
    #
    # @example Create an SPL Token mint
    #   # Initialize the program with a connection
    #   program = Solace::Programs::SplToken.new(connection: connection)
    #
    #   # Create an SPL Token mint
    #   result = program.create_mint(
    #     payer: payer,
    #     decimals: 6,
    #     mint_keypair: mint_keypair,
    #     mint_authority: mint_authority,
    #     freeze_authority: freeze_authority
    #   )
    #
    #   # Wait for the transaction to be finalized
    #   @connection.wait_for_confirmed_signature('finalized') { result['result'] }
    #
    # @since 0.0.2
    #
    # rubocop:disable Metrics/ClassLength
    class SplToken < Base
      # Initializes a new SPL Token client.
      #
      # @param connection [Solace::Connection] The connection to the Solana cluster.
      def initialize(connection:)
        super(connection: connection, program_id: Solace::Constants::TOKEN_PROGRAM_ID)
      end

      # Creates a new SPL Token mint.
      #
      # @param options [Hash] Options for calling the prepare_create_mint method.
      # @return [String] The signature of the transaction.
      def create_mint(**options)
        tx = prepare_create_mint(**options)

        @connection.send_transaction(tx.serialize)
      end

      # Prepares a new SPL Token mint and returns the signed transaction.
      #
      # @param payer [Solace::Keypair] The keypair that will pay for fees and rent.
      # @param decimals [Integer] The number of decimal places for the token.
      # @param mint_authority [String] The base58 public key for the mint authority.
      # @param freeze_authority [String] (Optional) The base58 public key for the freeze authority.
      # @param mint_keypair [Solace::Keypair] (Optional) The keypair for the new mint.
      # @return [Solace::Transaction] The signed transaction.
      #
      # rubocop:disable Metrics/MethodLength
      def prepare_create_mint(
        payer:,
        decimals:,
        mint_authority:,
        freeze_authority:,
        mint_keypair: Solace::Keypair.generate
      )
        accounts = [
          payer.to_s,
          mint_keypair.to_s,
          Solace::Constants::SYSVAR_RENT_PROGRAM_ID,
          Solace::Constants::TOKEN_PROGRAM_ID,
          Solace::Constants::SYSTEM_PROGRAM_ID
        ]

        rent_lamports = @connection.get_minimum_lamports_for_rent_exemption(82)

        create_account_ix = Solace::Instructions::SystemProgram::CreateAccountInstruction.build(
          from_index: 0,
          new_account_index: 1,
          system_program_index: 4,
          lamports: rent_lamports,
          space: 82,
          owner: program_id
        )

        freeze_authority = freeze_authority.to_s unless freeze_authority.nil?

        initialize_mint_ix = Solace::Instructions::SplToken::InitializeMintInstruction.build(
          mint_account_index: 1,
          rent_sysvar_index: 2,
          program_index: 3,
          decimals: decimals,
          mint_authority: mint_authority.to_s,
          freeze_authority: freeze_authority
        )

        message = Message.new(
          header: [2, 0, 3],
          accounts: accounts,
          recent_blockhash: @connection.get_latest_blockhash,
          instructions: [create_account_ix, initialize_mint_ix]
        )

        tx = Transaction.new(message: message)
        tx.sign(payer, mint_keypair)

        tx
      end
      # rubocop:enable Metrics/MethodLength

      # Mint tokens to a token account
      #
      # @param options [Hash] Options for calling the prepare_mint_to method.
      # @return [String] The signature of the transaction.
      def mint_to(**options)
        tx = prepare_mint_to(**options)

        @connection.send_transaction(tx.serialize)
      end

      # Prepares a mint to instruction and returns the signed transaction.
      #
      # @param [Integer] amount The amount of tokens to mint.
      # @param [PublicKey, Keypair, String] payer The payer of the transaction.
      # @param [PublicKey, Keypair, String] mint The mint of the token.
      # @param [PublicKey, Keypair, String] destination The destination of the token.
      # @param [PublicKey, Keypair, String] mint_authority The mint authority of the token.
      # @return [Solace::Transaction] The signed transaction.
      #
      # rubocop:disable Metrics/MethodLength
      def prepare_mint_to(
        payer:,
        mint:,
        destination:,
        amount:,
        mint_authority:
      )
        accounts = [
          payer.to_s,
          mint_authority.to_s,
          mint.to_s,
          destination.to_s,
          Solace::Constants::TOKEN_PROGRAM_ID.to_s
        ]

        ix = Solace::Instructions::SplToken::MintToInstruction.build(
          amount: amount,
          mint_authority_index: 1,
          mint_index: 2,
          destination_index: 3,
          program_index: 4
        )

        message = Solace::Message.new(
          header: [2, 0, 1],
          accounts: accounts,
          instructions: [ix],
          recent_blockhash: connection.get_latest_blockhash
        )

        tx = Solace::Transaction.new(message: message)
        tx.sign(payer, mint_authority)

        tx
      end
      # rubocop:enable Metrics/MethodLength

      # Transfers tokens from one account to another
      #
      # @param options [Hash] Options for calling the prepare_transfer method.
      # @return [String] The signature of the transaction.
      def transfer(**options)
        tx = prepare_transfer(**options)

        @connection.send_transaction(tx.serialize)
      end

      # Prepares a transfer instruction and returns the signed transaction.
      #
      # @param payer [Solace::Keypair] The keypair that will pay for fees and rent.
      # @param source [String] The source token account address.
      # @param destination [String] The destination token account address.
      # @param amount [Integer] The number of tokens to transfer.
      # @param owner [Solace::Keypair] The keypair of the owner of the source account.
      # @return [Solace::Transaction] The signed transaction.
      #
      # rubocop:disable Metrics/MethodLength
      def prepare_transfer(
        amount:,
        payer:,
        source:,
        destination:,
        owner:
      )
        accounts = [
          payer.to_s,
          owner.to_s,
          source.to_s,
          destination.to_s,
          Solace::Constants::TOKEN_PROGRAM_ID.to_s
        ]

        ix = Solace::Instructions::SplToken::TransferInstruction.build(
          amount: amount,
          owner_index: 1,
          source_index: 2,
          destination_index: 3,
          program_index: 4
        )

        message = Solace::Message.new(
          header: [2, 0, 1],
          accounts: accounts,
          instructions: [ix],
          recent_blockhash: connection.get_latest_blockhash
        )

        tx = Solace::Transaction.new(message: message)
        tx.sign(payer, owner)

        tx
      end
      # rubocop:enable Metrics/MethodLength
    end
    # rubocop:enable Metrics/ClassLength
  end
end
</file>

<file path="lib/solace/serializers/transaction_serializer.rb">
# frozen_string_literal: true

module Solace
  module Serializers
    # Serializes a Solana transaction to a binary format.
    #
    # @since 0.0.1
    class TransactionSerializer < Solace::Serializers::BaseSerializer
      # @!attribute SIGNATURE_PLACEHOLDER
      #   @return [String] Placeholder for a signature in the transaction
      SIGNATURE_PLACEHOLDER = ([0] * 64).pack('C*')

      # @!attribute steps
      #   An ordered list of methods to serialize the transaction
      #
      # @return [Array] The steps to serialize the transaction
      self.steps = %i[
        encode_signatures
        encode_message
      ]

      # Encodes the signatures of the transaction
      #
      # Iterates over the number sum number of signatures and either encodes or sets
      # the placeholder for each expected index in the signatures array.
      #
      # The BufferLayout is:
      #   - [Number of signatures (compact u16)]
      #   - [Signatures (variable length)]
      #
      # @return [Array<Integer>] The bytes of the encoded signatures
      def encode_signatures
        Codecs.encode_compact_u16(record.message.num_required_signatures).bytes +
          index_signatures(record.message.num_required_signatures)
      end

      # Encodes the message from the transaction
      #
      # @return [Array<Integer>] The bytes of the encoded message
      def encode_message
        record.message.to_bytes
      end

      private

      # Index the signatures
      #
      # Positions the signatures by expected index and set placeholders for any missing signatures.
      #
      # @param num_required_signatures [Integer] The number of required signatures
      #
      # @return [Array<Integer>] The bytes of the encoded signatures
      def index_signatures(num_required_signatures)
        (0...num_required_signatures).map { (record.signatures[_1] || SIGNATURE_PLACEHOLDER).bytes }
      end
    end
  end
end
</file>

<file path="lib/solace/keypair.rb">
# frozen_string_literal: true

require 'rbnacl'
require 'base58'

module Solace
  # Class representing a Solana Ed25519 Keypair
  #
  # This class provides utility methods for encoding, decoding, signing, and validating keypairs.
  #
  # @example
  #   # Generate a new keypair
  #   keypair = Solace::Keypair.generate
  #
  #   # Get the address of the pubkey
  #   keypair.address
  #
  #   # Sign a message using the keypair
  #   keypair.sign("<any-message>")
  #
  # @since 0.0.1
  class Keypair
    # The length of a Solana secret key in bytes.
    SECRET_LENGTH = 64

    # The length of a Solana seed in bytes.
    SEED_LENGTH = 32

    # The full keypair bytes array
    #
    # @return [Array<u8>] The 64 bytes of the keypair
    attr_reader :keypair_bytes

    class << self
      # Generate a new random keypair
      #
      # @example
      #   keypair = Solace::Keypair.generate
      #
      # @return [Keypair]
      def generate
        from_seed(RbNaCl::Random.random_bytes(SEED_LENGTH))
      end

      # Create a keypair from a 32-byte seed
      #
      # @example
      #   keypair = Solace::Keypair.from_seed(seed)
      #
      # @param seed [String] 32-byte array
      # @raise [ArgumentError] If the length of the seed isn't 32 bytes
      # @return [Keypair]
      def from_seed(seed)
        raise ArgumentError, 'Seed must be 32 bytes' unless seed.length == SEED_LENGTH

        new(RbNaCl::Signatures::Ed25519::SigningKey.new(seed).keypair_bytes.bytes)
      end

      # Create a keypair from a 64-byte secret key
      #
      # @example
      #   keypair = Solace::Keypair.from_secret_key(secret_key)
      #
      # @param secret_key [String] 64-byte array
      # @raise [ArgumentError] If the length of the secret_key isn't 64 bytes
      # @return [Keypair]
      def from_secret_key(secret_key)
        raise ArgumentError, 'Secret key must be 64 bytes' unless secret_key.length == SECRET_LENGTH

        new(RbNaCl::Signatures::Ed25519::SigningKey.new(secret_key[0..31]).keypair_bytes.bytes)
      end
    end

    # Initialize a new keypair
    #
    # @example
    #   keypair = Solace::Keypair.new(bytes)
    #
    # @param keypair_bytes [Array<Integer>] The keypair bytes
    # @raise [ArgumentError] If the length of the keypair_bytes isn't 64 bytes
    # @return [Keypair] The new keypair object
    def initialize(keypair_bytes)
      raise ArgumentError, 'Keypair must be 64 bytes' unless keypair_bytes.length == SECRET_LENGTH

      @keypair_bytes = keypair_bytes
    end

    # Returns the public key
    #
    # @example
    #   pubkey = keypair.public_key
    #
    # @return [PublicKey]
    def public_key
      @public_key ||= Solace::PublicKey.new(public_key_bytes)
    end

    # Returns the signing key
    #
    # @example
    #   signing_key = instance.signing_key
    #
    # @return [RbNaCl::Signatures::Ed25519::SigningKey]
    def signing_key
      @signing_key ||= RbNaCl::Signatures::Ed25519::SigningKey.new(private_key_bytes.pack('C*'))
    end

    # Returns the public key bytes
    #
    # The public key bytes are the last 32 bytes of the keypair
    #
    # @example
    #   public_key_bytes = instance.public_key_bytes
    #
    # @return [Array<u8>] 32 bytes
    def public_key_bytes
      keypair_bytes[32..63]
    end

    # Returns the private key
    #
    # The private key is the first 32 bytes of the keypair
    #
    # @example
    #   private_key_bytes = instance.private_key_bytes
    #
    # @return [Array<u8>] 32 characters
    def private_key_bytes
      keypair_bytes[0..31]
    end

    # Returns the public key address as a Base58 string
    #
    # @example
    #   pubkey_str = instance.to_base58
    #
    # @return [String] Base58 encoded public key
    def to_base58
      public_key.to_base58
    end

    # Returns the public key address as a Base58 string
    #
    # @example
    #   pubkey_str = instance.to_s
    #
    # @return [String] Base58 encoded public key
    # @since 0.0.8
    alias to_s to_base58

    # Returns the public key address as a Base58 string
    #
    # @example
    #   pubkey_str = instance.to_base58
    #
    # @return [String] Base58 encoded public key
    # @since 0.0.8
    alias address to_base58

    # Signs a message (string or binary)
    #
    # @example
    #   message = "An important message to be signed,"
    #   signature = instance.sign(message)
    #
    # @param message [String, Binary]
    # @return [String] signature (binary string)
    def sign(message)
      signing_key.sign(message)
    end
  end
end
</file>

<file path="lib/solace/transaction_composer.rb">
# frozen_string_literal: true

# lib/solace/transaction_composer.rb
module Solace
  # Composes multi-instruction transactions with automatic account management
  #
  # @example
  #   # Initialize a transaction composer
  #   composer = Solace::TransactionComposer.new(connection: connection)
  #
  #   # Add an instruction composer
  #   composer.add_instruction(
  #     Solace::Composers::SystemProgramTransferComposer.new(
  #       to: 'pubkey1',
  #       from: 'pubkey2',
  #       lamports: 100
  #     )
  #   )
  #
  #   # Add another instruction composer
  #   composer.add_instruction(
  #     Solace::Composers::SplTokenProgramTransferCheckedComposer.new(
  #       from: 'pubkey4',
  #       to: 'pubkey5',
  #       mint: 'pubkey6',
  #       authority: 'pubkey7',
  #       amount: 1_000_000,
  #       decimals: 6
  #     )
  #   )
  #
  #   # Set the fee payer
  #   composer.set_fee_payer('pubkey8')
  #
  #   # Compose the transaction
  #   tx = composer.compose_transaction
  #
  #   # Sign the transaction with all required signers
  #   tx.sign(*required_signers)
  #
  # @since 0.0.6
  class TransactionComposer
    # @!attribute connection
    #   The connection to the Solana cluster
    attr_reader :connection

    # @!attribute context
    #   The account context
    attr_reader :context

    # @!attribute instruction_composers
    #   The instruction composers
    attr_reader :instruction_composers

    # Initialize the composer
    #
    # @param connection [Solace::Connection] The connection to the Solana cluster
    def initialize(connection:)
      @connection = connection
      @instruction_composers = []
      @context = Utils::AccountContext.new
    end

    # Add an instruction composer to the transaction
    #
    # @param composer [Composers::Base] The instruction composer
    # @return [TransactionComposer] Self for chaining
    def add_instruction(composer)
      merge_accounts(composer.account_context)
      instruction_composers << composer
      self
    end

    # Set the fee payer for the transaction
    #
    # @param pubkey [String, Solace::PublicKey, Solace::Keypair] The fee payer pubkey
    # @return [TransactionComposer] Self for chaining
    def set_fee_payer(pubkey)
      context.set_fee_payer(pubkey.to_s)
      self
    end

    # Compose the final transaction
    #
    # @return [Solace::Transaction] The composed transaction (unsigned)
    def compose_transaction
      context.compile

      message = Solace::Message.new(
        header: context.header,
        accounts: context.accounts,
        instructions: build_instructions,
        recent_blockhash: connection.get_latest_blockhash
      )

      Solace::Transaction.new(message: message)
    end

    private

    # Build all instructions with resolved indices
    #
    # @return [Array<Solace::Instruction>] The built instructions
    def build_instructions
      instruction_composers.map { _1.build_instruction(context) }.flatten
    end

    # Merge all accounts from another AccountContext into this one
    #
    # @param account_context [AccountContext] The other context to merge from
    def merge_accounts(account_context)
      context.merge_from(account_context)
    end
  end
end
</file>

<file path="lib/solace/transaction.rb">
# encoding: ASCII-8BIT
# frozen_string_literal: true

module Solace
  # Class representing a Solana transaction
  #
  # Transactions are the basic building blocks of Solana. They contain a message and an array of signatures. The
  # message contains the instructions to be executed and the accounts that are used by the instructions. The signatures
  # are the signatures of the accounts that are used by the instructions. This class provides methods for signing,
  # serializing, and deserializing transactions.
  #
  # The BufferLayout is:
  #   - [Signatures (variable length)]
  #   - [Version (1 byte)] (if versioned)
  #   - [Message header (3 bytes)]
  #   - [Account keys (variable length)]
  #   - [Recent blockhash (32 bytes)]
  #   - [Instructions (variable length)]
  #   - [Address lookup table (variable length)] (if versioned)
  #
  # @example
  #   # Create a new transaction
  #   tx = Solace::Transaction.new
  #
  #   # Add a message to the transaction
  #   tx.message = Solace::Message.new(**message_params)
  #
  #   # Sign the transaction
  #   tx.sign(payer_keypair)
  #
  # @since 0.0.1
  class Transaction
    include Solace::Concerns::BinarySerializable

    # @!attribute SERIALIZER
    #   @return [Solace::Serializers::TransactionSerializer] The serializer for the transaction
    SERIALIZER = Solace::Serializers::TransactionSerializer

    # @!attribute DESERIALIZER
    #   @return [Solace::Serializers::TransactionDeserializer] The deserializer for the transaction
    DESERIALIZER = Solace::Serializers::TransactionDeserializer

    # @!attribute SIGNATURE_PLACEHOLDER
    #   @return [String] Placeholder for a signature in the transaction
    SIGNATURE_PLACEHOLDER = Solace::Utils::Codecs.base58_to_binary('1' * 64)

    # @!attribute  [rw] signatures
    #   @return [Array<String>] Signatures of the transaction (binary)
    attr_accessor :signatures

    # @!attribute  [rw] message
    #   @return [Solace::Message] Message of the transaction
    attr_accessor :message

    class << self
      # Deserialize a base64 encoded transaction into a Solace::Transaction object
      #
      # @param base64_tx [String] The base64 encoded transaction
      # @return [Solace::Transaction] The deserialized transaction
      def from(base64_tx)
        DESERIALIZER.new(Solace::Utils::Codecs.base64_to_bytestream(base64_tx)).call
      end
    end

    # Initialize a new transaction
    #
    # @return [Solace::Transaction] The new transaction object
    def initialize(
      signatures: [],
      message: Solace::Message.new
    )
      super()
      @signatures = signatures
      @message = message
    end

    # Sign the transaction
    #
    # Calls sign_and_update_signatures for each keypair passed in.
    #
    # @param keypairs [Array<Solace::Keypair>] The keypairs to sign the transaction with
    # @return [Array<String>] The signatures of the transaction
    def sign(*keypairs)
      keypairs.map { |keypair| sign_and_update_signatures(keypair) }
    end

    private

    # Sign message and update signatures
    #
    # Signs the transaction's message and updates the signatures array with the
    # signature.
    #
    # @return [Array<String>] The signatures of the transaction
    def sign_and_update_signatures(keypair)
      keypair.sign(message.to_binary).tap { |signature| set_signature(keypair.address, signature) }
    end

    # Update the transaction signatures
    #
    # Updates the signatures array according to the accounts of the message.
    #
    # @param public_key [String] The public key of the signer
    # @param signature [String] The signature to insert
    def set_signature(public_key, signature)
      index = message.accounts.index(public_key)

      raise ArgumentError, 'Public key not found in transaction' if index.nil?

      signatures[index] = signature
    end
  end
end
</file>

<file path="lib/solace/utils/curve25519_dalek.rb">
# encoding: ASCII-8BIT
# frozen_string_literal: true

require 'ffi'

module Solace
  module Utils
    # Module for interacting with the Curve25519 Dalek library
    #
    # This module provides a wrapper around the Curve25519 Dalek library, which is a pure-Rust
    # implementation of the Curve25519 elliptic curve. It uses FFI to interface with the native
    # rust library when checking if a point is on the curve.
    #
    # @see Solace::Utils::PDA
    # @since 0.0.2
    module Curve25519Dalek
      extend FFI::Library

      # Load the native library
      #
      # If the platform is not supported, a RuntimeError is raised. The native library
      # can be built by compiling the Rust code in the root/ext directory.
      #
      # @return [String] The path to the native library
      # @raise [RuntimeError] If the platform is not supported
      libfile = case RUBY_PLATFORM
                when /linux/ then 'libcurve25519_dalek-linux/libcurve25519_dalek.so'
                when /darwin/ then 'libcurve25519_dalek-macos/libcurve25519_dalek.dylib'
                when /mingw|mswin/ then 'libcurve25519_dalek-windows/curve25519_dalek.dll'
                else raise 'Unsupported platform'
                end

      # !@attribute LIB_PATH
      # @return [String] The path to the native library
      LIB_PATH = File.expand_path(libfile, __dir__)

      # Load the native library
      ffi_lib LIB_PATH

      # Attach the native function
      attach_function :is_on_curve, [:pointer], :int

      # Checks if a point is on the curve
      #
      # @param bytes [Array] The bytes to check
      # @return [Boolean] True if the point is on the curve, false otherwise
      # @raise [ArgumentError] If the input is not 32 bytes
      def self.on_curve?(bytes)
        raise ArgumentError, 'Must be 32 bytes' unless bytes.bytesize == 32

        FFI::MemoryPointer.new(:uchar, 32) do |ptr|
          ptr.put_bytes(0, bytes)
          result = Curve25519Dalek.is_on_curve(ptr)

          case result
          when 1 then return true
          when 0 then return false
          else raise "Unexpected return code from native is_on_curve: #{result}"
          end
        end
      end
    end
  end
end
</file>

<file path="lib/solace/utils/pda.rb">
# encoding: ASCII-8BIT
# frozen_string_literal: true

require 'digest'

module Solace
  module Utils
    # Module for generating program addresses
    #
    # This module provides methods for generating program addresses from seeds and program IDs. It interfaces
    # with the Curve25519 Dalek library to check if a point is on the curve. It also provides a method for
    # converting seeds to bytes and a method for checking if a string looks like a base58 address.
    #
    # @see Solace::Utils::Curve25519Dalek
    # @since 0.0.1
    module PDA
      # InvalidPDAError is an error raised when an invalid PDA is generated
      class InvalidPDAError < StandardError; end

      # !@attribute PDA_MARKER
      # PDA_MARKER is the marker used in PDA calculations
      PDA_MARKER = 'ProgramDerivedAddress'

      # !@attribute MAX_BUMP_SEED
      # The maximum seed value for PDA calculations
      MAX_BUMP_SEED = 255

      # Finds a valid program address by trying different seeds
      #
      # @example Find a PDA with bump seed
      #   seeds = ['metadata', mint_address, 'edition']
      #   program_id = 'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s'
      #
      #   address, bump = Solace::Utils::PDA.find_program_address(seeds, program_id)
      #
      # @param seeds [Array] The seeds to use in the calculation
      # @param program_id [String] The program ID to use in the calculation
      # @return [Array] The program address and bump seed
      # @raise [InvalidPDAError] If no valid program address is found
      def self.find_program_address(seeds, program_id)
        MAX_BUMP_SEED.downto(0) do |bump|
          address = create_program_address(seeds + [bump], program_id)
          return [address, bump]
        rescue InvalidPDAError
          next
        end

        raise 'Unable to find a valid program address'
      end

      # Creates a program address from seeds and program ID
      #
      # @param seeds [Array] The seeds to use in the calculation
      # @param program_id [String] The program ID to use in the calculation
      # @return [String] The program address
      # @raise [InvalidPDAError] If the program address is invalid
      def self.create_program_address(seeds, program_id)
        seed_bytes = seeds.map { |seed| seed_to_bytes(seed) }.flatten

        program_id_bytes = Solace::Utils::Codecs.base58_to_bytes(program_id)

        combined = seed_bytes + program_id_bytes + PDA_MARKER.bytes

        hash_bin = Digest::SHA256.digest(combined.pack('C*'))

        raise InvalidPDAError if Solace::Utils::Curve25519Dalek.on_curve?(hash_bin)

        Solace::Utils::Codecs.bytes_to_base58(hash_bin.bytes)
      end

      # Prepares a list of seeds for creating a program address
      #
      # @param seed [String, Integer, Array] The seed to prepare
      # @return [Array] The prepared seeds
      def self.seed_to_bytes(seed)
        case seed
        when String
          looks_like_base58_address?(seed) ? Solace::Utils::Codecs.base58_to_bytes(seed) : seed.bytes
        when Integer
          seed.between?(0, 255) ? [seed] : seed.digits(256)
        when Array
          seed
        else
          seed.to_s.bytes
        end
      end

      # Checks if a string looks like a base58 address
      #
      # @param string [String] The string to check
      # @return [Boolean] True if the string looks like a base58 address, false otherwise
      def self.looks_like_base58_address?(string)
        string.length.between?(32, 44) &&
          Solace::Utils::Codecs.valid_base58?(string)
      end
    end
  end
end
</file>

<file path="lib/solace/constants.rb">
# frozen_string_literal: true

module Solace
  # Constants module
  #
  # Contains constants used across the library.
  #
  # @return [Module] Constants module
  module Constants
    # @!attribute SYSTEM_PROGRAM_ID
    #   The public key of the System Program (native SOL transfers, account creation, etc)
    #   This is the same across all Solana clusters
    SYSTEM_PROGRAM_ID = '11111111111111111111111111111111'

    # @!attribute SYSVAR_RENT_PROGRAM_ID
    #   The public key of the Rent Program
    #   This is the same across all Solana clusters
    SYSVAR_RENT_PROGRAM_ID = 'SysvarRent111111111111111111111111111111111'

    # @!attribute COMPUTE_BUDGET_PROGRAM_ID
    #   The public key of the Compute Budget Program
    #   This is the same across all Solana clusters
    COMPUTE_BUDGET_PROGRAM_ID = 'ComputeBudget111111111111111111111111111111'

    # @!attribute TOKEN_PROGRAM_ID
    #   The public key of the SPL Token Program
    #   This is the same across all Solana clusters
    TOKEN_PROGRAM_ID = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'

    # @!attribute ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID
    #   The public key of the Associated Token Account Program
    #   This is the same across all Solana clusters
    ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID = 'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL'

    # @!attribute MEMO_PROGRAM_ID
    #   The public key of the Memo Program
    #   This is the same across all Solana clusters
    MEMO_PROGRAM_ID = 'MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'

    # @!attribute ADDRESS_LOOKUP_TABLE_PROGRAM_ID
    #   The public key of the Address Lookup Table Program
    #   This is the same across all Solana clusters
    ADDRESS_LOOKUP_TABLE_PROGRAM_ID = 'AddressLookupTab1e1111111111111111111111111'

    # Loads the constants declared in a YAML file
    #
    # Developers require adding program addresses and mint accounts that will not
    # be added directly to Solace. This method allows for loading those constants
    # from a YAML file and extends the Constants module with them.
    #
    # The YAML file should be a hash of key-value pairs, where the key is the constant
    # name and the value is the constant value.
    #
    # @example
    #   # constants.yml
    #   devnet:
    #     my_program_id: some_devnet_program_id
    #     squads_program_id: some_devnet_program_id
    #     usdc_mint_account: some_devnet_program_id
    #     usdt_mint_account: some_devnet_program_id
    #
    #   mainnet:
    #     my_program_id: some_mainnet_program_id
    #     squads_program_id: some_mainnet_program_id
    #     usdc_mint_account: some_mainnet_program_id
    #     usdt_mint_account: some_mainnet_program_id
    #
    # @example
    #   Solace::Constants.load(
    #     path: '/home/user/my-project/config/constants.yml',
    #     namespace: 'devnet',
    #     protect_overrides: false
    #   )
    #
    #   Solace::Constants::MY_PROGRAM_ID
    #   Solace::Constants::SQUADS_PROGRAM_ID
    #   Solace::Constants::USDC_MINT_ACCOUNT
    #   Solace::Constants::USDT_MINT_ACCOUNT
    #
    # @param path [String] The path to the YAML file
    # @param namespace [String] The namespace to load the constants from
    # @param protect_overrides [Boolean] Whether to protect constants that are already defined
    # @return [void]
    # @raise [ArgumentError] If protect_overrides is on and a constant is already defined
    def self.load(
      path:,
      namespace: 'default',
      protect_overrides: true
    )
      content = YAML.load_file(path)

      content[namespace].each do |key, value|
        if const_defined?(key.upcase)
          raise ArgumentError, "Constant #{key} is already defined" if protect_overrides

          remove_const(key.upcase)
        end

        const_set(key.upcase, value)
      end
    end
  end
end
</file>

<file path="lib/solace/public_key.rb">
# frozen_string_literal: true

module Solace
  # Class representing a Solana Ed25519 Public Key
  #
  # This class provides utility methods for encoding, decoding, and validating public keys.
  #
  # @example
  #   # Initialize a public key from a 32-byte array
  #   pubkey = Solace::PublicKey.new(public_key_bytes)
  #
  #   # Get the address representation of the public key
  #   pubkey.to_base58
  #   pubkey.address
  #
  # @since 0.0.1
  class PublicKey
    include Solace::Utils::PDA

    # The length of a Solana public key in bytes
    LENGTH = 32

    # The maximum seed value for a Program Derived Address
    MAX_BUMP_SEED = 255

    # The marker for a Program Derived Address
    PDA_MARKER = 'ProgramDerivedAddress'

    # The bytes of the public key
    #
    # @return [Array<u8>] The bytes of the public key
    attr_reader :bytes

    # Initialize with a 32-byte array or string
    #
    # @example
    #   pubkey = Solace::PubKey.new(bytes)
    #
    # @param bytes [String, Array<Integer>] 32-byte array or string
    # @raise [ArgumentError] If the public key bytes length isn't 32 long
    # @return [PublicKey]
    def initialize(bytes)
      raise ArgumentError, "Public key must be #{LENGTH} bytes" unless bytes.length == LENGTH

      @bytes = bytes.freeze
    end

    # Return the base58 representation of the public key
    #
    # @example
    #   pubkey_str = instance.to_base58
    #
    # @return [String]
    # @since 0.0.1
    def to_base58
      Solace::Utils::Codecs.bytes_to_base58(@bytes)
    end

    # String representation (base58)
    #
    # @example
    #   pubkey_str = instance.to_s
    #
    # @return [String]
    # @since 0.0.8
    alias to_s to_base58

    # Return the address of the public key
    #
    # @example
    #   pubkey_str = instance.address
    #
    # @return [String]
    # @since 0.0.8
    alias address to_base58

    # Compare two public keys for equality
    #
    # @example
    #   pubkey1 == pubkey2
    #
    # @param other [PublicKey]
    # @return [Boolean]
    # @since 0.0.1
    def ==(other)
      other.is_a?(Solace::PublicKey) && other.bytes == bytes
    end

    # Return the public key as a byte array
    #
    # @example
    #   pubkey_bytes = instance.to_bytes
    #
    # @return [Array<Integer>]
    # @since 0.0.1
    def to_bytes
      @bytes.dup
    end

    class << self
      # Create a public key instance from a base58 address
      #
      # @example
      #   pubkey = Solace::PublicKey.from_address(address)
      #
      # @param address [String] The base58 address of the public key
      # @return [PublicKey] The public key instance
      # @raise [ArgumentError] If the address is not a valid base58 string
      #
      # @since 0.0.6
      def from_address(address)
        new(Solace::Utils::Codecs.base58_to_bytes(address))
      end
    end
  end
end
</file>

<file path="lib/solace/programs/associated_token_account.rb">
# frozen_string_literal: true

# The AssociatedTokenAccount program is a Solana program that provides a standardized way to create and manage token accounts.
#
# This class provides a Ruby interface to the Associated Token Account program, allowing you to easily
# find or create associated token accounts for a given wallet and mint.
#
# @see https://spl.solana.com/associated-token-account Solana Associated Token Account Program
#
# @author Sebastian Scholl
# @since 0.1.0
module Solace
  module Programs
    # Client for interacting with the Associated Token Account Program.
    #
    # This client provides methods for interacting with the Associated Token Account Program. It is a
    # wrapper around the SPL Token Program and provides a more convenient interface for creating and
    # managing associated token accounts.
    #
    # @example Create an associated token account
    #   # Initialize the program with a connection
    #   program = Solace::Programs::AssociatedTokenAccount.new(connection: connection)
    #
    #   # Create an associated token account
    #   result = program.create_associated_token_account(
    #     payer: payer,
    #     owner: owner,
    #     mint: mint
    #   )
    #
    #   # Wait for the transaction to be finalized
    #   @connection.wait_for_confirmed_signature('finalized') { result['result'] }
    #
    # @since 0.0.2
    class AssociatedTokenAccount < Base
      class << self
        # Gets the address of an associated token account.
        #
        # @param owner [Solace::Keypair, Solace::PublicKey] The keypair of the owner.
        # @param mint [Solace::Keypair, Solace::PublicKey] The keypair of the mint.
        # @return [String] The address of the associated token account.
        def get_address(owner:, mint:)
          Solace::Utils::PDA.find_program_address(
            [
              owner.to_s,
              Solace::Constants::TOKEN_PROGRAM_ID,
              mint.to_s
            ],
            Solace::Constants::ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID
          )
        end
      end

      # Initializes a new Associated Token Account client.
      #
      # @param connection [Solace::Connection] The connection to the Solana cluster.
      def initialize(connection:)
        super(connection: connection, program_id: Solace::Constants::ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID)
      end

      # Alias method for get_address
      #
      # @param options [Hash] A hash of options for the get_address class method
      # @return [Array<String, Integer>] The address of the associated token account and the bump seed
      def get_address(**options)
        self.class.get_address(**options)
      end

      # Gets the address of an associated token account, creating it if it doesn't exist.
      #
      # @param payer [Solace::Keypair] The keypair that will pay for fees and rent.
      # @param owner [Solace::Keypair, Solace::PublicKey] The keypair of the owner.
      # @param mint [Solace::Keypair, Solace::PublicKey] The keypair of the mint.
      # @param commitment [String] The commitment level for the get_account_info call.
      # @return [String] The address of the associated token account
      def get_or_create_address(payer:, owner:, mint:, commitment: 'confirmed')
        ata_address, _bump = get_address(owner: owner, mint: mint)

        account_balance = @connection.get_account_info(ata_address)

        return ata_address unless account_balance.nil?

        response = create_associated_token_account(payer: payer, owner: owner, mint: mint)

        raise 'Failed to create associated token account' unless response['result']

        @connection.wait_for_confirmed_signature(commitment) { response }

        ata_address
      end

      # Creates a new associated token account.
      #
      # @param options [Hash] Options for calling the prepare_create_associated_token_account method.
      # @return [String] The signature of the transaction.
      def create_associated_token_account(**options)
        tx = prepare_create_associated_token_account(**options)

        tx.sign(options[:payer])

        @connection.send_transaction(tx.serialize)
      end

      # Prepares a new associated token account and returns the signed transaction.
      #
      # @param owner [Solace::Keypair, Solace::PublicKey] The keypair of the owner.
      # @param mint [Solace::Keypair, Solace::PublicKey] The keypair of the mint.
      # @param payer [Solace::Keypair] The keypair that will pay for fees and rent.
      # @return [Solace::Transaction] The signed transaction.
      #
      def prepare_create_associated_token_account(
        payer:,
        owner:,
        mint:
      )
        ata_address, = get_address(owner: owner, mint: mint)

        ix = Solace::Composers::AssociatedTokenAccountProgramCreateAccountComposer.new(
          mint: mint,
          owner: owner,
          funder: payer,
          ata_address: ata_address
        )

        TransactionComposer
          .new(connection: connection)
          .set_fee_payer(payer)
          .add_instruction(ix)
          .compose_transaction
      end
    end
  end
end
</file>

<file path="lib/solace/version.rb">
# frozen_string_literal: true

# Solace::VERSION is the version of the Solace gem
module Solace
  VERSION = '0.0.9'
end
</file>

<file path="lib/solace/connection.rb">
# frozen_string_literal: true

require 'net/http'
require 'json'
require 'uri'

require 'solace/errors'
require 'solace/utils/rpc_client'

module Solace
  # Connection to a Solana RPC node
  #
  # This class provides methods for sending JSON-RPC requests to a Solana RPC node and parsing responses.
  # It includes methods for sending transactions, getting account information, and getting blockhashes.
  #
  # @example
  #   # Initialize the connection
  #   connection = Solace::Connection.new('http://localhost:8899', commitment: 'confirmed')
  #
  #   # Get account information
  #   connection.get_account_info(account.address)
  #
  #   # Request an airdrop
  #   result = connection.request_airdrop(account.address, 1000000)
  #
  #   # Wait for the transaction to be finalized
  #   connection.wait_for_confirmed_signature('finalized') { result['result'] }
  #
  # @raise [
  #   Solace::Errors::HTTPError,
  #   Solace::Errors::ParseError,
  #   Solace::Errors::RPCError,
  #   Solace::Errors::ConfirmationTimeout
  # ]
  # @since 0.0.1
  class Connection
    # @!attribute [r] rpc_url
    #   The URL of the Solana RPC node
    attr_reader :rpc_client

    # @!attribute [r] default_options
    #   The default options for RPC requests
    attr_reader :default_options

    # Initialize the connection with a default or custom RPC URL
    #
    # @param rpc_url [String] The URL of the Solana RPC node
    # @param commitment [String] The commitment level for RPC requests
    # @return [Solace::Connection] The connection object
    # @param [Integer] http_open_timeout The timeout for opening an HTTP connection
    # @param [Integer] http_read_timeout The timeout for reading an HTTP response
    def initialize(
      rpc_url = 'http://localhost:8899',
      commitment: 'confirmed',
      http_open_timeout: 30,
      http_read_timeout: 60
    )
      # Initialize the RPC client
      @rpc_client = Utils::RPCClient.new(
        rpc_url,
        open_timeout: http_open_timeout,
        read_timeout: http_read_timeout
      )

      # Set default options for rpc requests
      @default_options = {
        commitment: commitment,
        encoding: 'base64'
      }
    end

    # Sends a JSON-RPC request to the configured Solana RPC server.
    #
    # @param method [String] the JSON-RPC method name
    # @param params [Array] the parameters for the RPC method
    # @return [Hash] the parsed JSON response
    # @raise [
    #   Solace::Errors::HTTPError,
    #   Solace::Errors::ParseError,
    #   Solace::Errors::RPCError,
    #   Solace::Errors::ConfirmationTimeout
    # ]
    def rpc_request(method, params = [])
      request = build_rpc_request(method, params)
      response = perform_http_request(request)
      handle_rpc_response(response)
    end

    # Request an airdrop of lamports to a given address
    #
    # @param pubkey [String] The public key of the account to receive the airdrop
    # @param lamports [Integer] Amount of lamports to airdrop
    # @param [Hash{Symbol => Object}] options The options for the request
    # @return [String] The transaction signature of the airdrop
    def request_airdrop(pubkey, lamports, options = {})
      @rpc_client.rpc_request(
        'requestAirdrop',
        [
          pubkey,
          lamports,
          default_options.merge(options)
        ]
      )
    end

    # Get the latest blockhash from the Solana node
    #
    # @return [String] The latest blockhash
    def get_latest_blockhash
      @rpc_client.rpc_request('getLatestBlockhash').dig('result', 'value', 'blockhash')
    end

    # Get the minimum required lamports for rent exemption
    #
    # @param space [Integer] Number of bytes to allocate for the account
    # @return [Integer] The minimum required lamports
    def get_minimum_lamports_for_rent_exemption(space)
      @rpc_client.rpc_request('getMinimumBalanceForRentExemption', [space])['result']
    end

    # Get the account information from the Solana node
    #
    # @param pubkey [String] The public key of the account
    # @return [Object] The account information
    def get_account_info(pubkey)
      @rpc_client.rpc_request('getAccountInfo', [pubkey, default_options]).dig('result', 'value')
    end

    # Get the balance of a specific account
    #
    # @param pubkey [String] The public key of the account
    # @return [Integer] The balance of the account
    def get_balance(pubkey)
      @rpc_client.rpc_request('getBalance', [pubkey, default_options]).dig('result', 'value')
    end

    # Get the balance of a token account
    #
    # @param token_account [String] The public key of the token account
    # @return [Hash] Token account balance information with amount and decimals
    def get_token_account_balance(token_account)
      @rpc_client.rpc_request('getTokenAccountBalance', [token_account, default_options]).dig('result', 'value')
    end

    # Get the transaction by signature
    #
    # @param signature [String] The signature of the transaction
    # @return [Solace::Transaction] The transaction object
    # @param [Hash{Symbol => Object}] options
    def get_transaction(signature, options = { maxSupportedTransactionVersion: 0 })
      @rpc_client.rpc_request('getTransaction', [signature, default_options.merge(options)])['result']
    end

    # Get the signature status
    #
    # @param signatures [Array] The signatures of the transactions
    # @return [Object] The signature status
    def get_signature_statuses(signatures)
      @rpc_client.rpc_request('getSignatureStatuses',
                              [signatures, default_options.merge({ 'searchTransactionHistory' => true })])['result']
    end

    # Get the program accounts
    #
    # @param program_id [String] The program ID
    # @param filters [Array] The filters
    # @return [Array] The program accounts
    # @param [Hash{Symbol => Object}] options
    def get_program_accounts(program_id, filters)
      @rpc_client.rpc_request('getProgramAccounts', [program_id, default_options.merge(filters: filters)])['result']
    end

    # Get the signature status
    #
    # @param signature [String] The signature of the transaction
    # @return [Object] The signature status
    def get_signature_status(signature)
      get_signature_statuses([signature])
    end

    # Send a transaction to the Solana node
    #
    # @param transaction [Solace::Transaction] The transaction to send
    # @return [String] The signature of the transaction
    # @param [Hash{Symbol => Object}] options
    def send_transaction(transaction, options = {})
      @rpc_client.rpc_request('sendTransaction', [transaction, default_options.merge(options)])
    end

    # Wait until the yielded signature reaches the desired commitment or timeout.
    #
    # @param commitment [String] One of "processed", "confirmed", "finalized"
    # @param timeout [Numeric] seconds to wait before raising
    # @param interval [Numeric] polling interval in seconds
    # @yieldreturn [String, Hash] a signature string or a JSON-RPC hash with "result"
    # @return [String] the signature when the commitment is reached
    # @raise [ArgumentError, Errors::ConfirmationTimeout]
    def wait_for_confirmed_signature(
      commitment = 'confirmed',
      timeout: 60,
      interval: 0.1
    )
      raise ArgumentError, 'Block required' unless block_given?

      signature = extract_signature_from(yield)
      deadline = monotonic_deadline(timeout)

      # Wait for confirmation
      until dealine_passed?(deadline)
        return signature if commitment_reached?(signature, commitment)

        sleep interval
      end

      raise Errors::ConfirmationTimeout.format(signature, commitment, timeout)
    end

    private

    # Confirms the commitment is reached
    #
    # @param signature [String] The signature of the transaction
    # @param commitment [String] The commitment level not reached
    # @return [Boolean] Whether the commitment is reached
    def commitment_reached?(signature, commitment)
      get_signature_status(signature).dig('value', 0, 'confirmationStatus') == commitment
    end

    # Extracts signature from given value
    #
    # @param value [String, Object] The result of the yielded block
    # @return [String] The signature
    def extract_signature_from(value)
      value.is_a?(String) ? value : value['result']
    end

    # Checks if a timeout deadline has been reached
    #
    # @params deadline [Integer] The deadline for the timeout
    # @return [boolean] whether the dealine has passed
    def dealine_passed?(deadline)
      Process.clock_gettime(Process::CLOCK_MONOTONIC) >= deadline
    end

    # Sets a deadline given a timeout in seconds
    #
    # @params seconds [Integer] The seconds for the deadline
    # @return [Integer] The deadline in seconds
    def monotonic_deadline(seconds)
      Process.clock_gettime(Process::CLOCK_MONOTONIC) + seconds
    end
  end
end
</file>

<file path="test/test_helper.rb">
# frozen_string_literal: true

# test/test_helper.rb

# Loads the environment and runs all Minitest tests in the test directory

require 'minitest/mock'
require 'minitest/autorun'
require 'minitest/hooks/default'

if ENV['USE_GEM']
  puts 'Requiring installed gem'
  require 'solace'
else
  puts 'Requiring local files'
  solace = File.expand_path('../lib/solace.rb', __dir__)
  require solace
end

require_relative 'support/fixtures'
require_relative 'support/factory_bot'
require_relative 'support/solana_test_validator'
</file>

<file path="lib/solace.rb">
# frozen_string_literal: true

# 🏷️ Version
require_relative 'solace/version'

# 🛠️ Helpers
require_relative 'solace/errors'
require_relative 'solace/constants'
require_relative 'solace/connection'
require_relative 'solace/utils/codecs'
require_relative 'solace/utils/pda'
require_relative 'solace/utils/account_context'
require_relative 'solace/utils/curve25519_dalek'
require_relative 'solace/concerns/binary_serializable'

# ✨ Serializers
require_relative 'solace/serializers/base_serializer'
require_relative 'solace/serializers/base_deserializer'

# 🧬 Primitives
require_relative 'solace/keypair'
require_relative 'solace/public_key'
require_relative 'solace/transaction'
require_relative 'solace/message'
require_relative 'solace/instruction'
require_relative 'solace/address_lookup_table'
require_relative 'solace/transaction_composer'

# Base Classes (Abstract classes)
require_relative 'solace/programs/base'
require_relative 'solace/composers/base'

# 📦 Composers
#
# Glob require all composers
Dir[File.join(__dir__, 'solace/composers', '**', '*.rb')].each { |file| require file }

# 📦 Instructions (Builders)
#
# Glob require all instructions
Dir[File.join(__dir__, 'solace/instructions', '**', '*.rb')].each { |file| require file }

# 📦 Programs
require_relative 'solace/programs/spl_token'
require_relative 'solace/programs/associated_token_account'
</file>

</files>
